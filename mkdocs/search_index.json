{
    "docs": [
        {
            "location": "/",
            "text": "BSPLib\n\u00b6\n\n\nBSPLib\n is a fast, and easy to use C++ implementation of the Bulk Synchronous Parallel (BSP) threading model. This model is mainly used in the scientific computing field, but can also be applied more general in computer science. This library includes an extended version the standard BSP interface to perform better, and made it more easy to use.\n\n\nStatus\n\u00b6\n\n\n\n\n\n\n\n\nOS\n\n\nStatus\n\n\n\n\n\n\n\n\n\n\nLinux & OSX\n\n\n\n\n\n\n\n\nWindows\n\n\n\n\n\n\n\n\n\n\nBSP\n\u00b6\n\n\nThe BSP specification can be found \nhere\n and is maintained by \nbsp-worldwide.org\n. Parts of the\ndocumentation and code are based off this specification, to ensure backward compatibility between BSP libraries.\n\n\nZPM\n Installation\n\u00b6\n\n\nIn \n.package.json\n\n\n\"requires\": [\n        {\n            \"name\": \"Zefiros-Software/BSPLib\",\n            \"version\": \"^1.1.0\"\n        }\n]\n\n\n\n\nIn \npremake5.lua\n\n\nzpm.uses \"Zefiros-Software/BSPLib\"\n\n\n\n\nManual Installation\n\u00b6\n\n\nThe whole library is header only, so for usage in your own code you should clone the repository. And add \nbsp/include/\n as include path.\nAfter this you can use the include \n#include \"bsp/bsp.h\"\n in your code to start using the library.\n\n\nCode\n & \nDocumentation\n\u00b6\n\n\nThe code can be found \nhere\n. See \nthis\n for the documentation.\n\n\nFeatures\n\u00b6\n\n\n\n\nFast: All our code is hand optimised using profilers, to ensure maximum performance.\n\n\nReliable: We have an extensive testing suite, making sure we do not break forward and backward compatiblity.\n\n\nEasy to use: The library is completely header only. Also next to our improved c++ interface, we shipped the\nclassic BSP C interface.\n\n\nCross platform: Designed to only use C++11, with no external dependencies.\n\n\nWarning free, compiled on the highest warning level.\n\n\n\n\nUsage\n\u00b6\n\n\nFor detailed usage, please visit \nBSPLib\n.\n\n\nExample\n\n\nvoid main( int32_t, const char ** )\n{\n    BSPLib::Execute( []\n    {\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::ProcId() \n                  << \" of \" << BSPLib::NProcs() << std::endl;\n    }, BSPLib::NProcs() );\n}\n\n\n\n\nFlexibility\n\u00b6\n\n\nDon't like the legacy interface?\n\u00b6\n\n\nNo worries! You can easily disable the macros by defining:\n\n\n#define BSP_DISABLE_LEGACY\n\n\n\n\nSpeeding up debugging\n\u00b6\n\n\nWhen debug builds are too slow, you can remove the extra safety check by defining:\n\n\n#define BSP_SKIP_CHECKS\n\n\n\n\nBSPLib Limits\n\u00b6\n\n\n\n\nFor small programs, you may experience a lot of overhead in starting the threads.\n\n\nStarting more threads than available physical cores, may reduce perfomance.\n\n\nNo support for more nodes by TCP/UDP connections.\n\n\n\n\nPlanned Features\n\u00b6\n\n\n\n\nMultiBSP interface addition.\n\n\nUtility functions, such as broadcasting and various distributions.\n\n\nSubset synchronisation on BSPLib::Sync with both predicates and processors lists.\n  eg. BSPLib::Sync( [] { return BSPLib::ProcId() % 2 == 0; } ) and BSPLib::Sync( {1, 3, 4} )\n\n\nBenchLib version of BSP bench, so we can circumvent compiler optmisations and differences.\n\n\n\n\nBSPedupack\n\u00b6\n\n\nAs an example usage of the BSP programming model we included the BSPedupack written by \nRob H. Bisseling\n\nwith his permission. It includes some tools to benchmark and test the library on different machines, to quote\nfrom his own \nsite\n:\n\n\n\n\nBSPedupack is a library of numerical algorithms written in C according to the BSP model. \nIt uses the BSPlib standard library. The 'edu' in the name stands for educational. \nThe programs are intended for teaching: they give examples of portable parallel \nnumerical programs. The trade-off between clarity/brevity on the one hand, and efficiency \non the other hand is in favour of clarity/brevity. There is also an MPI version which \nteaches how to program in bulk synchronous parallel style using the collective communications\nfrom MPI-1 and the one-sided communications from MPI-2. You guessed it, this package is called \nMPIedupack. Both packages accompany the book: \nParallel Scientific Computation: \nA Structured Approach using BSP and MPI\n, \nby \nRob H. Bisseling\n, Oxford University Press, \nMarch 2004. ISBN 978-0-19-852939-2.\n\n\n\n\nAlternatives\n\u00b6\n\n\n\n\nMulticoreBSP\n\n\nOxford BSP Toolkit\n\n\nBSPonMPI\n\n\n\n\nWhy BSPLib?\n\u00b6\n\n\nWe wanted an easy to use, high performing BSP model implementation, but of course there\nwere some alternatives.\n\n\nBSPLib vs MulticoreBSP\n\u00b6\n\n\n\n\nBSPLib is headeronly, whilst MulticoreBSP requires linking.\n\n\nBSPLib is crossplatform, but MulticoreBSP requires POSIX compatibility.\n\n\nMulticoreBSP can be compiled with a C compiler.\n\n\nMulticoreBSP programs will compile faster.\n\n\nBSPLib can disable sanity checks to boost performance.\n\n\nBSPLib will only synchronise the used functionality, so we have faster synchronisation.\n\n\n\n\nBSPLib vs Oxford BSP Toolkit\n\u00b6\n\n\n\n\nBSPLib is headeronly, whilst Oxford BSP Toolkit requires linking.\n\n\nOxford BSP Toolkit programs will compile faster.\n\n\n\n\nBSPLib vs BSPonMPI\n\u00b6\n\n\n\n\nBSPLib is headeronly, whilst BSPonMPI requires linking.\n\n\nBSPLib uses a permissive license (MIT), whereas BSPonMPI uses (LGPL).\n\n\nBSPonMPI is based on MPI, so it uses another abstraction layer, whereas BSPLib uses a low level\n  threading interface.\n\n\nBSPonMPI programs will compile faster.\n\n\n\n\nBugs\n\u00b6\n\n\nWhen a bug is found, please insert it in the issue tracker, so we can resolve it as quickly as we can.\n\n\nContributing\n\u00b6\n\n\n\n\nFork it!\n\n\nCreate your feature branch: \ngit checkout -b my-new-feature\n\n\nCommit your changes: \ngit commit -am 'Add some feature'\n\n\nPush to the branch: \ngit push origin my-new-feature\n\n\nSubmit a pull request\n\n\n\n\nAuthors\n\u00b6\n\n\n\n\nMick van Duijn \nm.vanduijn@zefiros.eu\n\n\nPaul Visscher \np.e.visscher@zefiros.eu\n\n\nKoen Visscher \nk.m.visscher@zefiros.eu\n\n\n\n\nUsed By\n\u00b6\n\n\nWe are interested to find out what projects use BSPLib. We would love to include your projects here, \njust shoot us a mail. :)\n\n\nCiting BSPLib\n\u00b6\n\n\nWhen you use BSPLib as part of a scientific publication, we would love you to cite this project. This BibTex snippet can be used:\n\n\n@misc{bsplib2016,\n  author    = {Mick van Duijn and Koen Visscher and Paul Visscher},\n  title     = {{BSPLib}: a fast, and easy to use {C++} implementation of the {Bulk} {Synchronous} {Parallel} ({BSP}) threading model.},\n  abstract  = {{BSPLib} is a fast, and easy to use {C++} implementation of the {Bulk} {Synchronous} {Parallel} ({BSP}) threading model. This model is mainly used in the scientific computing field, but can also be applied more general in computer science. This library includes an extended version the standard BSP interface to perform better, and made it more easy to use.},\n  howpublished = {\\url{http://bsplib.eu/}}\n}\n\n\n\n\nLicense\n\u00b6\n\n\nThis project is licensed under the MIT license.\n\n\nCopyright (c) 2016 Mick van Duijn, Koen Visscher and Paul Visscher\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.",
            "title": "Home"
        },
        {
            "location": "/#bsplib",
            "text": "BSPLib  is a fast, and easy to use C++ implementation of the Bulk Synchronous Parallel (BSP) threading model. This model is mainly used in the scientific computing field, but can also be applied more general in computer science. This library includes an extended version the standard BSP interface to perform better, and made it more easy to use.",
            "title": "BSPLib"
        },
        {
            "location": "/#status",
            "text": "OS  Status      Linux & OSX     Windows",
            "title": "Status"
        },
        {
            "location": "/#bsp",
            "text": "The BSP specification can be found  here  and is maintained by  bsp-worldwide.org . Parts of the\ndocumentation and code are based off this specification, to ensure backward compatibility between BSP libraries.",
            "title": "BSP"
        },
        {
            "location": "/#zpm_installation",
            "text": "In  .package.json  \"requires\": [\n        {\n            \"name\": \"Zefiros-Software/BSPLib\",\n            \"version\": \"^1.1.0\"\n        }\n]  In  premake5.lua  zpm.uses \"Zefiros-Software/BSPLib\"",
            "title": "ZPM Installation"
        },
        {
            "location": "/#manual_installation",
            "text": "The whole library is header only, so for usage in your own code you should clone the repository. And add  bsp/include/  as include path.\nAfter this you can use the include  #include \"bsp/bsp.h\"  in your code to start using the library.",
            "title": "Manual Installation"
        },
        {
            "location": "/#code_documentation",
            "text": "The code can be found  here . See  this  for the documentation.",
            "title": "Code &amp; Documentation"
        },
        {
            "location": "/#features",
            "text": "Fast: All our code is hand optimised using profilers, to ensure maximum performance.  Reliable: We have an extensive testing suite, making sure we do not break forward and backward compatiblity.  Easy to use: The library is completely header only. Also next to our improved c++ interface, we shipped the\nclassic BSP C interface.  Cross platform: Designed to only use C++11, with no external dependencies.  Warning free, compiled on the highest warning level.",
            "title": "Features"
        },
        {
            "location": "/#usage",
            "text": "For detailed usage, please visit  BSPLib .  Example  void main( int32_t, const char ** )\n{\n    BSPLib::Execute( []\n    {\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::ProcId() \n                  << \" of \" << BSPLib::NProcs() << std::endl;\n    }, BSPLib::NProcs() );\n}",
            "title": "Usage"
        },
        {
            "location": "/#flexibility",
            "text": "",
            "title": "Flexibility"
        },
        {
            "location": "/#dont_like_the_legacy_interface",
            "text": "No worries! You can easily disable the macros by defining:  #define BSP_DISABLE_LEGACY",
            "title": "Don't like the legacy interface?"
        },
        {
            "location": "/#speeding_up_debugging",
            "text": "When debug builds are too slow, you can remove the extra safety check by defining:  #define BSP_SKIP_CHECKS",
            "title": "Speeding up debugging"
        },
        {
            "location": "/#bsplib_limits",
            "text": "For small programs, you may experience a lot of overhead in starting the threads.  Starting more threads than available physical cores, may reduce perfomance.  No support for more nodes by TCP/UDP connections.",
            "title": "BSPLib Limits"
        },
        {
            "location": "/#planned_features",
            "text": "MultiBSP interface addition.  Utility functions, such as broadcasting and various distributions.  Subset synchronisation on BSPLib::Sync with both predicates and processors lists.\n  eg. BSPLib::Sync( [] { return BSPLib::ProcId() % 2 == 0; } ) and BSPLib::Sync( {1, 3, 4} )  BenchLib version of BSP bench, so we can circumvent compiler optmisations and differences.",
            "title": "Planned Features"
        },
        {
            "location": "/#bspedupack",
            "text": "As an example usage of the BSP programming model we included the BSPedupack written by  Rob H. Bisseling \nwith his permission. It includes some tools to benchmark and test the library on different machines, to quote\nfrom his own  site :   BSPedupack is a library of numerical algorithms written in C according to the BSP model. \nIt uses the BSPlib standard library. The 'edu' in the name stands for educational. \nThe programs are intended for teaching: they give examples of portable parallel \nnumerical programs. The trade-off between clarity/brevity on the one hand, and efficiency \non the other hand is in favour of clarity/brevity. There is also an MPI version which \nteaches how to program in bulk synchronous parallel style using the collective communications\nfrom MPI-1 and the one-sided communications from MPI-2. You guessed it, this package is called \nMPIedupack. Both packages accompany the book:  Parallel Scientific Computation: \nA Structured Approach using BSP and MPI , \nby  Rob H. Bisseling , Oxford University Press, \nMarch 2004. ISBN 978-0-19-852939-2.",
            "title": "BSPedupack"
        },
        {
            "location": "/#alternatives",
            "text": "MulticoreBSP  Oxford BSP Toolkit  BSPonMPI",
            "title": "Alternatives"
        },
        {
            "location": "/#why_bsplib",
            "text": "We wanted an easy to use, high performing BSP model implementation, but of course there\nwere some alternatives.",
            "title": "Why BSPLib?"
        },
        {
            "location": "/#bsplib_vs_multicorebsp",
            "text": "BSPLib is headeronly, whilst MulticoreBSP requires linking.  BSPLib is crossplatform, but MulticoreBSP requires POSIX compatibility.  MulticoreBSP can be compiled with a C compiler.  MulticoreBSP programs will compile faster.  BSPLib can disable sanity checks to boost performance.  BSPLib will only synchronise the used functionality, so we have faster synchronisation.",
            "title": "BSPLib vs MulticoreBSP"
        },
        {
            "location": "/#bsplib_vs_oxford_bsp_toolkit",
            "text": "BSPLib is headeronly, whilst Oxford BSP Toolkit requires linking.  Oxford BSP Toolkit programs will compile faster.",
            "title": "BSPLib vs Oxford BSP Toolkit"
        },
        {
            "location": "/#bsplib_vs_bsponmpi",
            "text": "BSPLib is headeronly, whilst BSPonMPI requires linking.  BSPLib uses a permissive license (MIT), whereas BSPonMPI uses (LGPL).  BSPonMPI is based on MPI, so it uses another abstraction layer, whereas BSPLib uses a low level\n  threading interface.  BSPonMPI programs will compile faster.",
            "title": "BSPLib vs BSPonMPI"
        },
        {
            "location": "/#bugs",
            "text": "When a bug is found, please insert it in the issue tracker, so we can resolve it as quickly as we can.",
            "title": "Bugs"
        },
        {
            "location": "/#contributing",
            "text": "Fork it!  Create your feature branch:  git checkout -b my-new-feature  Commit your changes:  git commit -am 'Add some feature'  Push to the branch:  git push origin my-new-feature  Submit a pull request",
            "title": "Contributing"
        },
        {
            "location": "/#authors",
            "text": "Mick van Duijn  m.vanduijn@zefiros.eu  Paul Visscher  p.e.visscher@zefiros.eu  Koen Visscher  k.m.visscher@zefiros.eu",
            "title": "Authors"
        },
        {
            "location": "/#used_by",
            "text": "We are interested to find out what projects use BSPLib. We would love to include your projects here, \njust shoot us a mail. :)",
            "title": "Used By"
        },
        {
            "location": "/#citing_bsplib",
            "text": "When you use BSPLib as part of a scientific publication, we would love you to cite this project. This BibTex snippet can be used:  @misc{bsplib2016,\n  author    = {Mick van Duijn and Koen Visscher and Paul Visscher},\n  title     = {{BSPLib}: a fast, and easy to use {C++} implementation of the {Bulk} {Synchronous} {Parallel} ({BSP}) threading model.},\n  abstract  = {{BSPLib} is a fast, and easy to use {C++} implementation of the {Bulk} {Synchronous} {Parallel} ({BSP}) threading model. This model is mainly used in the scientific computing field, but can also be applied more general in computer science. This library includes an extended version the standard BSP interface to perform better, and made it more easy to use.},\n  howpublished = {\\url{http://bsplib.eu/}}\n}",
            "title": "Citing BSPLib"
        },
        {
            "location": "/#license",
            "text": "This project is licensed under the MIT license.  Copyright (c) 2016 Mick van Duijn, Koen Visscher and Paul Visscher\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.",
            "title": "License"
        },
        {
            "location": "/classic/",
            "text": "The Classic BSP Interface\n\u00b6\n\n\nSince BSP originally was a C library, the whole interface was designed \nto be used from C. We made the interface easier to work with from C++, \nbut we also provide the classic interface implementation.\n\n\nProgram Logic\n\u00b6\n\n\n\n\n\n\n\n\nClassic\n\n\nModern\n\n\n\n\n\n\n\n\n\n\nbsp_init()\n\n\nBSPLib::Classic::Init()\n\n\n\n\n\n\nbsp_begin()\n\n\nBSPLib::Classic::Begin()\n\n\n\n\n\n\nbsp_end()\n\n\nBSPLib::Classic::End()\n\n\n\n\n\n\n\n\nUtilities\n\u00b6\n\n\n\n\n\n\n\n\nClassic\n\n\nModern\n\n\n\n\n\n\n\n\n\n\nbsp_pid()\n\n\nBSPLib::ProcId()\n\n\n\n\n\n\nbsp_nprocs()\n\n\nBSPLib::NProcs()\n\n\n\n\n\n\nbsp_time()\n\n\nBSPLib::Time()\n\n\n\n\n\n\n\n\nHalting\n\u00b6\n\n\n\n\n\n\n\n\nClassic\n\n\nModern\n\n\n\n\n\n\n\n\n\n\nbsp_abort()\n\n\nBSPLib::Classic::Abort()\n\n\n\n\n\n\nbsp_vabort()\n\n\nBSPLib::Classic::VAbort()\n\n\n\n\n\n\n\n\nSynchronisation Point\n\u00b6\n\n\n\n\n\n\n\n\nClassic\n\n\nModern\n\n\n\n\n\n\n\n\n\n\nbsp_sync()\n\n\nBSPLib::Sync()\n\n\n\n\n\n\n\n\nRegistration & Deregistration\n\u00b6\n\n\n\n\n\n\n\n\nClassic\n\n\nModern\n\n\n\n\n\n\n\n\n\n\nbsp_push_reg()\n\n\nBSPLib::Push()\n\n\n\n\n\n\nbsp_pop_reg()\n\n\nBSPLib::Pop()\n\n\n\n\n\n\n\n\nCommunication\n\u00b6\n\n\n\n\n\n\n\n\nClassic\n\n\nModern\n\n\n\n\n\n\n\n\n\n\nbsp_put()\n\n\nBSPLib::Put()\n\n\n\n\n\n\nbsp_get()\n\n\nBSPLib::Get()\n\n\n\n\n\n\n\n\nMessaging\n\u00b6\n\n\n\n\n\n\n\n\nClassic\n\n\nModern\n\n\n\n\n\n\n\n\n\n\nbsp_send()\n\n\nBSPLib::Send()\n\n\n\n\n\n\nbsp_qsize()\n\n\nBSPLib::QSize()\n\n\n\n\n\n\nbsp_move()\n\n\nBSPLib::Move()\n\n\n\n\n\n\n\n\nMessaging Utilities\n\u00b6\n\n\n\n\n\n\n\n\nClassic\n\n\nModern\n\n\n\n\n\n\n\n\n\n\nbsp_set_tagsize()\n\n\nBSPLib::SetTagSize()\n\n\n\n\n\n\nbsp_get_tag()\n\n\nBSPLib::GetTag()",
            "title": "Classic"
        },
        {
            "location": "/classic/#the_classic_bsp_interface",
            "text": "Since BSP originally was a C library, the whole interface was designed \nto be used from C. We made the interface easier to work with from C++, \nbut we also provide the classic interface implementation.",
            "title": "The Classic BSP Interface"
        },
        {
            "location": "/classic/#program_logic",
            "text": "Classic  Modern      bsp_init()  BSPLib::Classic::Init()    bsp_begin()  BSPLib::Classic::Begin()    bsp_end()  BSPLib::Classic::End()",
            "title": "Program Logic"
        },
        {
            "location": "/classic/#utilities",
            "text": "Classic  Modern      bsp_pid()  BSPLib::ProcId()    bsp_nprocs()  BSPLib::NProcs()    bsp_time()  BSPLib::Time()",
            "title": "Utilities"
        },
        {
            "location": "/classic/#halting",
            "text": "Classic  Modern      bsp_abort()  BSPLib::Classic::Abort()    bsp_vabort()  BSPLib::Classic::VAbort()",
            "title": "Halting"
        },
        {
            "location": "/classic/#synchronisation_point",
            "text": "Classic  Modern      bsp_sync()  BSPLib::Sync()",
            "title": "Synchronisation Point"
        },
        {
            "location": "/classic/#registration_deregistration",
            "text": "Classic  Modern      bsp_push_reg()  BSPLib::Push()    bsp_pop_reg()  BSPLib::Pop()",
            "title": "Registration &amp; Deregistration"
        },
        {
            "location": "/classic/#communication",
            "text": "Classic  Modern      bsp_put()  BSPLib::Put()    bsp_get()  BSPLib::Get()",
            "title": "Communication"
        },
        {
            "location": "/classic/#messaging",
            "text": "Classic  Modern      bsp_send()  BSPLib::Send()    bsp_qsize()  BSPLib::QSize()    bsp_move()  BSPLib::Move()",
            "title": "Messaging"
        },
        {
            "location": "/classic/#messaging_utilities",
            "text": "Classic  Modern      bsp_set_tagsize()  BSPLib::SetTagSize()    bsp_get_tag()  BSPLib::GetTag()",
            "title": "Messaging Utilities"
        },
        {
            "location": "/logic/execute/",
            "text": "Interfaces\n\u00b6\n\n\nbool Execute( std::function< void() > func, uint32_t nProc )    // (1) Simple\nbool Execute( std::function< void() > func, uint32_t nProc, \n              int32_t argc, char **argv )                       // (2) Arguments\n\n\n\n\nThis function executes the given function according to the BSP model, with the\ngiven amount of processors. There is no need to seperate main thread and instanced threads from the library, \nand also \nBSPLib::Classic::Begin()\n and \nBSPLib::Classic::End()\n are not needed in \nthis function body. Everything is taken care off, and if the computations are abored prematurely,\nthe return value will be false instead of true.\n\n\nThis function is sematically equal to:\n\n\nstd::function< void() > spmd = [func, nProc]\n{\n    BSPLib::Classic::Begin( nProc );\n\n    func();\n\n    BSPLib::Classic::End();\n};\n\nBSPLib::Classic::Init( spmd, argc, argv );\n\ntry\n{\n    spmd();\n}\ncatch ( BspInternal::BspAbort & )\n{\n    return false;\n}\n\nreturn true;\n\n\n\n\nA BSP program normally is paired by \nBSPLib::Classic::Begin()\n \nand \nBSPLib::Classic::End()\n calls. When using the normal execution mode\n\nBSPLib::Classic::Init()\n needs to be called beforehand, otherwise \nthe computations will start in SPMD mode, and the behaviour will be undefined.\nTo solve this we introduce the \nBSPLib::Execute()\n function makes the\nBSP interface easier to use.\n\n\n\n\nThis is the most basic way of calling this function.\n\n\nWhen we need to pass the \nmain()\n arguments to the BSP program.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\nfunc\n   The entry function to execute over all processors.\n\n\nnProcs\n The amount of processors to use in the executions.\n\n\nargc\n   \nCurrently not used, should be \nargc\n from \nmain\n function.\n\n\nargv\n   \nCurrently not used, should be \nargv\n from \nmain\n function.\n\n\n\n\nReturn Value\n\u00b6\n\n\nTrue when the BSP program executed successfully, othwerise false.\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nThe BSP program has been executed.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Simple\n\u00b6\n\n\nNormal\n\n\nThis is the normal usage of the function.\n\n\nvoid main( int32_t, const char ** )\n{\n    BSPLib::Execute( []\n    {\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n                  << \" of \" << BSPLib::NProcs() << std::endl;\n    }, BSPLib::NProcs() );\n}\n\n\n\n\nNon Gracefull Exit\n\n\nIf the computation could call abort, one can check for it on the return type.\n\n\nvoid main( int32_t, const char ** )\n{\n    bool success = BSPLib::Execute( []\n    {\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n                  << \" of \" << BSPLib::NProcs() << std::endl;\n\n        if ( BSPLib::ProcId() == 0 )\n        {\n            BSPLib::Abort( \"Quit non gracefully\" );\n        }\n    }, BSPLib::NProcs() );\n\n    assert( !success );\n}\n\n\n\n\n(2) Arguments\n\u00b6\n\n\nvoid main( int32_t argc, const char **argv )\n{\n    BSPLib::Execute( []\n    {\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n                  << \" of \" << BSPLib::NProcs() << std::endl;\n    }, BSPLib::NProcs(), argc, argv );\n}",
            "title": "Execute BSP Kernel"
        },
        {
            "location": "/logic/execute/#interfaces",
            "text": "bool Execute( std::function< void() > func, uint32_t nProc )    // (1) Simple\nbool Execute( std::function< void() > func, uint32_t nProc, \n              int32_t argc, char **argv )                       // (2) Arguments  This function executes the given function according to the BSP model, with the\ngiven amount of processors. There is no need to seperate main thread and instanced threads from the library, \nand also  BSPLib::Classic::Begin()  and  BSPLib::Classic::End()  are not needed in \nthis function body. Everything is taken care off, and if the computations are abored prematurely,\nthe return value will be false instead of true.  This function is sematically equal to:  std::function< void() > spmd = [func, nProc]\n{\n    BSPLib::Classic::Begin( nProc );\n\n    func();\n\n    BSPLib::Classic::End();\n};\n\nBSPLib::Classic::Init( spmd, argc, argv );\n\ntry\n{\n    spmd();\n}\ncatch ( BspInternal::BspAbort & )\n{\n    return false;\n}\n\nreturn true;  A BSP program normally is paired by  BSPLib::Classic::Begin()  \nand  BSPLib::Classic::End()  calls. When using the normal execution mode BSPLib::Classic::Init()  needs to be called beforehand, otherwise \nthe computations will start in SPMD mode, and the behaviour will be undefined.\nTo solve this we introduce the  BSPLib::Execute()  function makes the\nBSP interface easier to use.   This is the most basic way of calling this function.  When we need to pass the  main()  arguments to the BSP program.",
            "title": "Interfaces"
        },
        {
            "location": "/logic/execute/#parameters",
            "text": "func    The entry function to execute over all processors.  nProcs  The amount of processors to use in the executions.  argc     Currently not used, should be  argc  from  main  function.  argv     Currently not used, should be  argv  from  main  function.",
            "title": "Parameters"
        },
        {
            "location": "/logic/execute/#return_value",
            "text": "True when the BSP program executed successfully, othwerise false.",
            "title": "Return Value"
        },
        {
            "location": "/logic/execute/#post-conditions",
            "text": "The BSP program has been executed.",
            "title": "Post-Conditions"
        },
        {
            "location": "/logic/execute/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/logic/execute/#1_simple",
            "text": "Normal  This is the normal usage of the function.  void main( int32_t, const char ** )\n{\n    BSPLib::Execute( []\n    {\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n                  << \" of \" << BSPLib::NProcs() << std::endl;\n    }, BSPLib::NProcs() );\n}  Non Gracefull Exit  If the computation could call abort, one can check for it on the return type.  void main( int32_t, const char ** )\n{\n    bool success = BSPLib::Execute( []\n    {\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n                  << \" of \" << BSPLib::NProcs() << std::endl;\n\n        if ( BSPLib::ProcId() == 0 )\n        {\n            BSPLib::Abort( \"Quit non gracefully\" );\n        }\n    }, BSPLib::NProcs() );\n\n    assert( !success );\n}",
            "title": "(1) Simple"
        },
        {
            "location": "/logic/execute/#2_arguments",
            "text": "void main( int32_t argc, const char **argv )\n{\n    BSPLib::Execute( []\n    {\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n                  << \" of \" << BSPLib::NProcs() << std::endl;\n    }, BSPLib::NProcs(), argc, argv );\n}",
            "title": "(2) Arguments"
        },
        {
            "location": "/logic/init/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::Init( std::function< void() > spmd, \n                            int32_t argc, char **argv)          // (1) Classic\nvoid bsp_init( void(*spmd)(void), int32_t argc, char **argv)    // (2) BSP\n\n\n\n\nInitialises the BSP computation process. Please note that the main thread should also call the entry function.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\n\n\nWarnings\n\n\n\n\nBy default, \nBSPLib::Classic::Init()\n will print a warning to \nstderr\n in case an abort of the previous BSP program has been detected. This message can be suppressed by the symbol \nBSP_SUPPRESS_ABORT_WARNING\n.\n\n\nWhen \nBSPLib::Classic::Init()\n failed to join all threads from the previous BSP program, an error will be printed to \nstderr\n, and the entire program will be terminated by \nstd::terminate()\n. This behaviour cannot be disabled, as it will most certainly cause errors in the next BSP    program.\n\n\n\n\n\n\n\n\nDeprication\n\n\nThis function has been depricated in favour of \nBSPLib::Execute()\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\nspmd\n The entry function to execute.\n\n\nargc\n \nCurrently not used, should be \nargc\n from \nmain\n function.\n\n\nargv\n \nCurrently not used, should be \nargv\n from \nmain\n function.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nIf the previous BSP program was terminated using Abort or VAbort:\n\n\nBSPLib will try to end the previous BSP program by notifying all threads that are stuck in a synchronisation about the previous Abort.\n\n\nAfter 100 failed tries, the entire program will be terminated by \nstd::terminate()\n.\n\n\n\n\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nTag size is 0.\n\n\nEntry point is now \nentry\n, thus when we call \nBSPLib::Classic::Begin()\n all threads except for the\n   main thread will execute this function.\n\n\nFor the main thread, \nBSPLib::ProcId() == 0\n, other threads get their identifier assigned\n   in the \nBSPLib::Classic::Begin()\n function.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\nSPMD Exectution\n\n\nIn SPMD mode, BSPLib regocnises no \nBSPLib::Classic::Init\n has been called,\nand thus automatically recalls the \nmain()\n function for the other threads.\n\n\nvoid main(int32_t, const char **)\n{\n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    BSPLib::Classic::End();\n}\n\n\n\n\nNormal Exectution\n\n\nIn the normal execution mode we need to initialise the BSPLibrary with a \nBSPLib::Classic::Init\n call.\nThis ensures we assign the correct entry point to the threads, which will be called on the\n\nBSPLib::Classic::Begin()\n call.\n\n\nvoid Spmd()\n{  \n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    BSPLib::Classic::End();\n}\n\n\nvoid main(int32_t argc, const char **argv)\n{\n    BSPLib::Classic::Init( Spmd, argc, argv );\n    // Main thread needs to call it also\n    Spmd();\n}\n\n\n\n\nLambda Exectution\n\n\nA more advanced manner of execution is using lambda, giving our \nmore freedom over small BSP programs. Since we now use \nstd::function< void() >\n\nas entry point, we are no longer bound by function pointers. \nBSPLib::Execute()\n\nis a nice abstraction over this programming method, and should be used in favour of calling the\nprogram logic functions yourself.\n\n\nvoid main( int32_t argc, const char **argv )\n{\n    auto entry = []\n    {\n        BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n                << \" of \" << BSPLib::NProcs() << std::endl;\n\n        BSPLib::Classic::End();\n    };\n\n    // Set the entry point for the other threads\n    BSPLib::Classic::Init( entry, argc, argv );\n\n    // Main thread needs to call it also\n    entry();\n}\n\n\n\n\n(2) BSP\n\u00b6\n\n\nvoid Spmd()\n{  \n    bsp_begin( bsp_nprocs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << bsp_pid() \n              << \" of \" << bsp_nprocs() << std::endl;\n\n    bsp_end();\n}\n\n\nvoid main(int32_t argc, const char **argv)\n{\n    bsp_init( Spmd, argc, argv );\n    // Main thread needs to call it also\n    Spmd();\n}",
            "title": "Init BSP Kernel"
        },
        {
            "location": "/logic/init/#interfaces",
            "text": "void BSPLib::Classic::Init( std::function< void() > spmd, \n                            int32_t argc, char **argv)          // (1) Classic\nvoid bsp_init( void(*spmd)(void), int32_t argc, char **argv)    // (2) BSP  Initialises the BSP computation process. Please note that the main thread should also call the entry function.   Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.    Warnings   By default,  BSPLib::Classic::Init()  will print a warning to  stderr  in case an abort of the previous BSP program has been detected. This message can be suppressed by the symbol  BSP_SUPPRESS_ABORT_WARNING .  When  BSPLib::Classic::Init()  failed to join all threads from the previous BSP program, an error will be printed to  stderr , and the entire program will be terminated by  std::terminate() . This behaviour cannot be disabled, as it will most certainly cause errors in the next BSP    program.     Deprication  This function has been depricated in favour of  BSPLib::Execute() .",
            "title": "Interfaces"
        },
        {
            "location": "/logic/init/#parameters",
            "text": "spmd  The entry function to execute.  argc   Currently not used, should be  argc  from  main  function.  argv   Currently not used, should be  argv  from  main  function.",
            "title": "Parameters"
        },
        {
            "location": "/logic/init/#pre-conditions",
            "text": "If the previous BSP program was terminated using Abort or VAbort:  BSPLib will try to end the previous BSP program by notifying all threads that are stuck in a synchronisation about the previous Abort.  After 100 failed tries, the entire program will be terminated by  std::terminate() .",
            "title": "Pre-Conditions"
        },
        {
            "location": "/logic/init/#post-conditions",
            "text": "Tag size is 0.  Entry point is now  entry , thus when we call  BSPLib::Classic::Begin()  all threads except for the\n   main thread will execute this function.  For the main thread,  BSPLib::ProcId() == 0 , other threads get their identifier assigned\n   in the  BSPLib::Classic::Begin()  function.",
            "title": "Post-Conditions"
        },
        {
            "location": "/logic/init/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/logic/init/#1_classic",
            "text": "SPMD Exectution  In SPMD mode, BSPLib regocnises no  BSPLib::Classic::Init  has been called,\nand thus automatically recalls the  main()  function for the other threads.  void main(int32_t, const char **)\n{\n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    BSPLib::Classic::End();\n}  Normal Exectution  In the normal execution mode we need to initialise the BSPLibrary with a  BSPLib::Classic::Init  call.\nThis ensures we assign the correct entry point to the threads, which will be called on the BSPLib::Classic::Begin()  call.  void Spmd()\n{  \n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    BSPLib::Classic::End();\n}\n\n\nvoid main(int32_t argc, const char **argv)\n{\n    BSPLib::Classic::Init( Spmd, argc, argv );\n    // Main thread needs to call it also\n    Spmd();\n}  Lambda Exectution  A more advanced manner of execution is using lambda, giving our \nmore freedom over small BSP programs. Since we now use  std::function< void() > \nas entry point, we are no longer bound by function pointers.  BSPLib::Execute() \nis a nice abstraction over this programming method, and should be used in favour of calling the\nprogram logic functions yourself.  void main( int32_t argc, const char **argv )\n{\n    auto entry = []\n    {\n        BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n        std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n                << \" of \" << BSPLib::NProcs() << std::endl;\n\n        BSPLib::Classic::End();\n    };\n\n    // Set the entry point for the other threads\n    BSPLib::Classic::Init( entry, argc, argv );\n\n    // Main thread needs to call it also\n    entry();\n}",
            "title": "(1) Classic"
        },
        {
            "location": "/logic/init/#2_bsp",
            "text": "void Spmd()\n{  \n    bsp_begin( bsp_nprocs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << bsp_pid() \n              << \" of \" << bsp_nprocs() << std::endl;\n\n    bsp_end();\n}\n\n\nvoid main(int32_t argc, const char **argv)\n{\n    bsp_init( Spmd, argc, argv );\n    // Main thread needs to call it also\n    Spmd();\n}",
            "title": "(2) BSP"
        },
        {
            "location": "/logic/begin/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::Begin( uint32_t p ) // (1) Classic\nvoid bsp_begin( uint32_t p )              // (2) BSP\n\n\n\n\nBegins the computations with the maximum given processors. The BSP model is implemented around the \nSingle Program Multiple Data (SPMD) programming model. This means that we divide our datastructures \nover all threads, and try to evenly divide the work per processor. BSPLib will handle the required \ncommunication, as implemented by the user. This means that the distribution of work\nis the users responsibility, whilst the communication is that of the library.\n\n\nUsually we create a BSP program by pairing (optionally) \nBSPLib::Classic::Init()\n, \nBSPLib::Classic::Begin()\n \nand \nBSPLib::Classic::End()\n calls. When no \nBSPLib::Classic::Init()\n call is made, the library resumes in \nSPMD mode, and calls the \nmain()\n function in all threads. Otherwise the given entry point from the\n\nBSPLib::Classic::Init()\n call will be used.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\n\n\nDeprication\n\n\nThis function has been depricated in favour of \nBSPLib::Execute()\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\np\n The maximum processors to use in computation. Assigning more processors than \n      physically available could slow down your program.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\n\n\nIf Init has been called: \n\n\n\n\nWill execute entry in parallel.\n\n\n\n\nElse: \n\n\n\n\nWill execute main in parallel. Also, a warning will be printed to \nstderr\n.\n\n\n\n\n\n\n\n\nIf called from the main thread:\n\n\n\n\nResets and initialises the communication queues and buffers.\n\n\nCalls the entry point for all other threads.\n\n\nStarts the timer for the main thread.\n   Else:\n Starts the timer for the current thread.\n\n\n\n\n\n\n\n\nExceptions\n\u00b6\n\n\n\n\nBspInternal::BspAbort\n: \n  Thrown when an abort error condition occurs, if enabled with symbol \nBSP_THROW\n.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\nSPMD Exectution\n\n\nIn SPMD mode, BSPLib regocnises no \nBSPLib::Classic::Init\n has been called,\nand thus automatically recalls the \nmain()\n function for the other threads.\n\n\nvoid main( int32_t, const char ** )\n{\n    // No Init call, so other threads will call\n    // the main fuction\n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    BSPLib::Classic::End();\n}\n\n\n\n\nOf course namespaces may be ommited, so the interface gets even simpler.\n\n\nvoid main( int32_t, const char ** )\n{\n    using namespace BSPLib;\n\n    // No Init call, so other threads will call\n    // the main fuction\n    Classic::Begin( NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << ProcId() \n              << \" of \" << NProcs() << std::endl;\n\n    Classic::End();\n}\n\n\n\n\nNormal Exectution\n\n\nIn the normal execution mode we need to initialise the BSPLibrary with a \nBSPLib::Classic::Init\n call.\nThis ensures we assign the correct entry point to the threads, which will be called on the\n\nBSPLib::Classic::Begin()\n call.\n\n\nvoid Spmd()\n{  \n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    BSPLib::Classic::End();\n}\n\n\nvoid main( int32_t argc, const char **argv )\n{\n    // Set the entry point for the other threads\n    BSPLib::Classic::Init( Spmd, argc, argv );\n\n    // Main thread needs to call it also\n    Spmd();\n}\n\n\n\n\n(2) BSP\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    // No Init call, so other threads will call\n    // the main fuction\n    bsp_begin( bsp_nprocs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << bsp_pid() \n            << \" of \" << bsp_nprocs() << std::endl;\n\n    bsp_end();\n}",
            "title": "Begin BSP Kernel"
        },
        {
            "location": "/logic/begin/#interfaces",
            "text": "void BSPLib::Classic::Begin( uint32_t p ) // (1) Classic\nvoid bsp_begin( uint32_t p )              // (2) BSP  Begins the computations with the maximum given processors. The BSP model is implemented around the \nSingle Program Multiple Data (SPMD) programming model. This means that we divide our datastructures \nover all threads, and try to evenly divide the work per processor. BSPLib will handle the required \ncommunication, as implemented by the user. This means that the distribution of work\nis the users responsibility, whilst the communication is that of the library.  Usually we create a BSP program by pairing (optionally)  BSPLib::Classic::Init() ,  BSPLib::Classic::Begin()  \nand  BSPLib::Classic::End()  calls. When no  BSPLib::Classic::Init()  call is made, the library resumes in \nSPMD mode, and calls the  main()  function in all threads. Otherwise the given entry point from the BSPLib::Classic::Init()  call will be used.   Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.    Deprication  This function has been depricated in favour of  BSPLib::Execute() .",
            "title": "Interfaces"
        },
        {
            "location": "/logic/begin/#parameters",
            "text": "p  The maximum processors to use in computation. Assigning more processors than \n      physically available could slow down your program.",
            "title": "Parameters"
        },
        {
            "location": "/logic/begin/#pre-conditions",
            "text": "If Init has been called:    Will execute entry in parallel.   Else:    Will execute main in parallel. Also, a warning will be printed to  stderr .     If called from the main thread:   Resets and initialises the communication queues and buffers.  Calls the entry point for all other threads.  Starts the timer for the main thread.\n   Else:\n Starts the timer for the current thread.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/logic/begin/#exceptions",
            "text": "BspInternal::BspAbort : \n  Thrown when an abort error condition occurs, if enabled with symbol  BSP_THROW .",
            "title": "Exceptions"
        },
        {
            "location": "/logic/begin/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/logic/begin/#1_classic",
            "text": "SPMD Exectution  In SPMD mode, BSPLib regocnises no  BSPLib::Classic::Init  has been called,\nand thus automatically recalls the  main()  function for the other threads.  void main( int32_t, const char ** )\n{\n    // No Init call, so other threads will call\n    // the main fuction\n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    BSPLib::Classic::End();\n}  Of course namespaces may be ommited, so the interface gets even simpler.  void main( int32_t, const char ** )\n{\n    using namespace BSPLib;\n\n    // No Init call, so other threads will call\n    // the main fuction\n    Classic::Begin( NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << ProcId() \n              << \" of \" << NProcs() << std::endl;\n\n    Classic::End();\n}  Normal Exectution  In the normal execution mode we need to initialise the BSPLibrary with a  BSPLib::Classic::Init  call.\nThis ensures we assign the correct entry point to the threads, which will be called on the BSPLib::Classic::Begin()  call.  void Spmd()\n{  \n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    BSPLib::Classic::End();\n}\n\n\nvoid main( int32_t argc, const char **argv )\n{\n    // Set the entry point for the other threads\n    BSPLib::Classic::Init( Spmd, argc, argv );\n\n    // Main thread needs to call it also\n    Spmd();\n}",
            "title": "(1) Classic"
        },
        {
            "location": "/logic/begin/#2_bsp",
            "text": "void main( int32_t, const char ** )\n{\n    // No Init call, so other threads will call\n    // the main fuction\n    bsp_begin( bsp_nprocs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << bsp_pid() \n            << \" of \" << bsp_nprocs() << std::endl;\n\n    bsp_end();\n}",
            "title": "(2) BSP"
        },
        {
            "location": "/logic/end/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::End() // (1) Classic\nvoid bsp_end()                // (2) BSP\n\n\n\n\nEnds the BSP computation. All threads must call this function to gracefully exit the BSP program. A BSP program is paired by \nBSPLib::Classic::Begin()\n \nand \nBSPLib::Classic::End()\n calls. Wherein the \nBSPLib::Classic::End()\n should be the last call in the computation. Calling this function\nwill ensure that the library is reset for reuse, and thuse we can restart calculations or start another SPMD program.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\n\n\nDeprication\n\n\nThis function has been depricated in favour of \nBSPLib::Execute()\n.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBegin has been called\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nEnded is true\n\n\nAll threads have synced and ended.\n\n\nThe main thread releases all threads.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{        \n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    // Stop all the threads, reset the library\n    // and resume execution on the main thread.\n    BSPLib::Classic::End();\n}\n\n\n\n\n(2) BSP\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    // Stop all the threads, reset the library\n    // and resume execution on the main thread.\n    BSPLib::Classic::End();\n}",
            "title": "End BSP Kernel"
        },
        {
            "location": "/logic/end/#interfaces",
            "text": "void BSPLib::Classic::End() // (1) Classic\nvoid bsp_end()                // (2) BSP  Ends the BSP computation. All threads must call this function to gracefully exit the BSP program. A BSP program is paired by  BSPLib::Classic::Begin()  \nand  BSPLib::Classic::End()  calls. Wherein the  BSPLib::Classic::End()  should be the last call in the computation. Calling this function\nwill ensure that the library is reset for reuse, and thuse we can restart calculations or start another SPMD program.   Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.    Deprication  This function has been depricated in favour of  BSPLib::Execute() .",
            "title": "Interfaces"
        },
        {
            "location": "/logic/end/#pre-conditions",
            "text": "Begin has been called",
            "title": "Pre-Conditions"
        },
        {
            "location": "/logic/end/#post-conditions",
            "text": "Ended is true  All threads have synced and ended.  The main thread releases all threads.",
            "title": "Post-Conditions"
        },
        {
            "location": "/logic/end/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/logic/end/#1_classic",
            "text": "void main( int32_t, const char ** )\n{        \n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    // Stop all the threads, reset the library\n    // and resume execution on the main thread.\n    BSPLib::Classic::End();\n}",
            "title": "(1) Classic"
        },
        {
            "location": "/logic/end/#2_bsp",
            "text": "void main( int32_t, const char ** )\n{\n    BSPLib::Classic::Begin( BSPLib::NProcs() );\n\n    std::cout << \"Hello BSP Worldwide from process \" << BSPLib::Classic::ProcId() \n              << \" of \" << BSPLib::NProcs() << std::endl;\n\n    // Stop all the threads, reset the library\n    // and resume execution on the main thread.\n    BSPLib::Classic::End();\n}",
            "title": "(2) BSP"
        },
        {
            "location": "/halting/abort/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::Abort( const char *errorMessage, ... )           // (1) Classic\nvoid bsp_abort( const char *errorMessage, ... )                        // (2) BSP\nvoid BSPLib::VAbort( const char *errorMessage, va_list args )          // (3) Modern va_list\nvoid bsp_vabort( const char *errorMessage, va_list args )              // (4) BSP va_list\n\n\n\n\nAborts the BSP program with the given error message. The formatting used is the same as in\nfprintf. If more than one processors calls \nBSPLib::Abort()\n, then\nall processors may print the abort message, and not just one. \n\n\nThe thread that aborts prints the message to \nstderr\n.\nInstead of terminating the whole program, it just terminates\nthe computation, and thus you are able to continue or restart\nthe program. When you use \nBSPLib::Execute()\n\nyou can query whether the program was aborted or not. When  \nBSPLib::Execute()\n\nis not used, the main thread may throw an exception.\n\n\nIf \nBSPLib::Init()\n is called after an abort, it will determine whether all threads have actually \naborted. If not, it will notify the waiting threads about the abort. If even this fails, the entire program will terminate.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\nClassic BSP function that takes a \nva_list\n directly.\n\n\nLegacy BSP function that takes a \nva_list\n directly.\n\n\n\n\n\n\nWarnings\n\n\nThe termination behaviour is different in BSPLib differs from that in other BSP libraries.\n\n\n\n\n\n\nDeprication\n\n\nThis function has been depricated and should be avoided.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\nformat\n Describes the message to format.\n\n\n...\n    Variable arguments providing message formatting.\n\n\nargs\n   The formatting arguments.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nAll threads other than main thread will exit on a BSP call, unless the BSP process is restarted.\n\n\nIf main thread, a BSPAbort exception will be thrown.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    bool success = BSPLib::Execute( []\n    {\n        if ( BSPLib::Classic::ProcId() == 0 )\n        {\n            // Prints \"Quit non gracefully\"\n            BSPLib::Classic::Abort( \"Quit non gracefully\" );\n\n            // Will never be reached\n            while( true );\n        }\n\n        BSPLib::Classic::Sync();\n\n    }, BSPLib::Classic::NProcs() );\n\n    assert( !success );\n}\n\n\n\n\n(2) BSP\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    bool success = BSPLib::Execute( []\n    {\n        if ( bsp_pid() == 0 )\n        {\n            // Prints \"Quit non gracefully\"\n            bsp_abort( \"Quit non gracefully\" );\n\n            // Will never be reached\n            while( true );\n        }\n\n        bsp_sync();\n\n    }, bsp_nprocs() );\n\n    assert( !success );\n}",
            "title": "Abort Program"
        },
        {
            "location": "/halting/abort/#interfaces",
            "text": "void BSPLib::Classic::Abort( const char *errorMessage, ... )           // (1) Classic\nvoid bsp_abort( const char *errorMessage, ... )                        // (2) BSP\nvoid BSPLib::VAbort( const char *errorMessage, va_list args )          // (3) Modern va_list\nvoid bsp_vabort( const char *errorMessage, va_list args )              // (4) BSP va_list  Aborts the BSP program with the given error message. The formatting used is the same as in\nfprintf. If more than one processors calls  BSPLib::Abort() , then\nall processors may print the abort message, and not just one.   The thread that aborts prints the message to  stderr .\nInstead of terminating the whole program, it just terminates\nthe computation, and thus you are able to continue or restart\nthe program. When you use  BSPLib::Execute() \nyou can query whether the program was aborted or not. When   BSPLib::Execute() \nis not used, the main thread may throw an exception.  If  BSPLib::Init()  is called after an abort, it will determine whether all threads have actually \naborted. If not, it will notify the waiting threads about the abort. If even this fails, the entire program will terminate.   Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.  Classic BSP function that takes a  va_list  directly.  Legacy BSP function that takes a  va_list  directly.    Warnings  The termination behaviour is different in BSPLib differs from that in other BSP libraries.    Deprication  This function has been depricated and should be avoided.",
            "title": "Interfaces"
        },
        {
            "location": "/halting/abort/#parameters",
            "text": "format  Describes the message to format.  ...     Variable arguments providing message formatting.  args    The formatting arguments.",
            "title": "Parameters"
        },
        {
            "location": "/halting/abort/#post-conditions",
            "text": "All threads other than main thread will exit on a BSP call, unless the BSP process is restarted.  If main thread, a BSPAbort exception will be thrown.",
            "title": "Post-Conditions"
        },
        {
            "location": "/halting/abort/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/halting/abort/#1_classic",
            "text": "void main( int32_t, const char ** )\n{\n    bool success = BSPLib::Execute( []\n    {\n        if ( BSPLib::Classic::ProcId() == 0 )\n        {\n            // Prints \"Quit non gracefully\"\n            BSPLib::Classic::Abort( \"Quit non gracefully\" );\n\n            // Will never be reached\n            while( true );\n        }\n\n        BSPLib::Classic::Sync();\n\n    }, BSPLib::Classic::NProcs() );\n\n    assert( !success );\n}",
            "title": "(1) Classic"
        },
        {
            "location": "/halting/abort/#2_bsp",
            "text": "void main( int32_t, const char ** )\n{\n    bool success = BSPLib::Execute( []\n    {\n        if ( bsp_pid() == 0 )\n        {\n            // Prints \"Quit non gracefully\"\n            bsp_abort( \"Quit non gracefully\" );\n\n            // Will never be reached\n            while( true );\n        }\n\n        bsp_sync();\n\n    }, bsp_nprocs() );\n\n    assert( !success );\n}",
            "title": "(2) BSP"
        },
        {
            "location": "/util/nprocs/",
            "text": "Interfaces\n\u00b6\n\n\nuint32_t BSPLib::NProcs()           // (1) Modern\nuint32_t BSPLib::Classic::NProcs()  // (2) Classic\nuint32_t bsp_nprocs()               // (3) BSP\n\n\n\n\nGets the the amount of processors used by the BSP library. When the BSP library is not\ninitialised this returns the amount of processors available in hardware. After initalisation\nit returns the maximum amount of processors available as initialised. \n\n\n\n\nThis is interface one should choose to use, and is semantically the same as the other interfaces.\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\nReturn Value\n\u00b6\n\n\nThe amount of processors available.\n\n\nPre-Conditions\n\u00b6\n\n\n\n\n\n\nIf Begin has been called:\n\n\n\n\nReturns the number of started threads.\n\n\n\n\nElse:\n\n\n\n\nReturns the number of physical threads available.\n\n\n\n\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Modern\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::NProcs();\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  BSPLib::NProcs() << std::endl;\n    }, nProcs );\n\n    // prints: \"The amount of processors we started with equals 3\", 3 times\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  BSPLib::NProcs() << std::endl;\n    }, 3 );\n}\n\n\n\n\n(2) Classic\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::Classic::NProcs();\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  BSPLib::Classic::NProcs() << std::endl;\n    }, nProcs );\n\n    // prints: \"The amount of processors we started with equals 3\", 3 times\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  BSPLib::Classic::NProcs() << std::endl;\n    }, 3 );\n}\n\n\n\n\n(3) BSP\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = bsp_nprocs();\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  bsp_nprocs() << std::endl;\n    }, nProcs );\n\n    // prints: \"The amount of processors we started with equals 3\", 3 times\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  bsp_nprocs() << std::endl;\n    }, 3 );\n}",
            "title": "Processor Count"
        },
        {
            "location": "/util/nprocs/#interfaces",
            "text": "uint32_t BSPLib::NProcs()           // (1) Modern\nuint32_t BSPLib::Classic::NProcs()  // (2) Classic\nuint32_t bsp_nprocs()               // (3) BSP  Gets the the amount of processors used by the BSP library. When the BSP library is not\ninitialised this returns the amount of processors available in hardware. After initalisation\nit returns the maximum amount of processors available as initialised.    This is interface one should choose to use, and is semantically the same as the other interfaces.  Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.",
            "title": "Interfaces"
        },
        {
            "location": "/util/nprocs/#return_value",
            "text": "The amount of processors available.",
            "title": "Return Value"
        },
        {
            "location": "/util/nprocs/#pre-conditions",
            "text": "If Begin has been called:   Returns the number of started threads.   Else:   Returns the number of physical threads available.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/util/nprocs/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/util/nprocs/#1_modern",
            "text": "void main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::NProcs();\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  BSPLib::NProcs() << std::endl;\n    }, nProcs );\n\n    // prints: \"The amount of processors we started with equals 3\", 3 times\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  BSPLib::NProcs() << std::endl;\n    }, 3 );\n}",
            "title": "(1) Modern"
        },
        {
            "location": "/util/nprocs/#2_classic",
            "text": "void main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::Classic::NProcs();\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  BSPLib::Classic::NProcs() << std::endl;\n    }, nProcs );\n\n    // prints: \"The amount of processors we started with equals 3\", 3 times\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  BSPLib::Classic::NProcs() << std::endl;\n    }, 3 );\n}",
            "title": "(2) Classic"
        },
        {
            "location": "/util/nprocs/#3_bsp",
            "text": "void main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = bsp_nprocs();\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  bsp_nprocs() << std::endl;\n    }, nProcs );\n\n    // prints: \"The amount of processors we started with equals 3\", 3 times\n    BSPLib::Execute( []\n    {\n        std::cout << \"The amount of processors we started with equals \" <<  bsp_nprocs() << std::endl;\n    }, 3 );\n}",
            "title": "(3) BSP"
        },
        {
            "location": "/util/procid/",
            "text": "Interfaces\n\u00b6\n\n\nuint32_t BSPLib::ProcId()            // (1) Modern\nuint32_t BSPLib::Classic::ProcId()  // (2) Classic\nuint32_t bsp_pid()                    // (3) BSP\n\n\n\n\nWhen \nBSPLib::Classic::Begin()\n has been called, all processors other than the main thread\nwill get a unique identifier assigned in the range \n[1, [BSPLib::NProcs() - 1]\n. The main \nthread holds identifier \n0\n.\n\n\n\n\nThis is interface one should choose to use, and is semantically the same as the other interfaces.\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\nReturn Value\n\u00b6\n\n\nThe current processor identifier.\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Classic::Begin()\n has been called, otherwise\n  this will return \n0xdeadbeef\n.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Modern\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The current processor identifier is `x`\", with x between 0 and `nProcs` - 1.\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  BSPLib::ProcId() << std::endl;\n    }, nProcs );\n\n    // prints: \"The current processor identifier is 0\"\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  BSPLib::ProcId() << std::endl;\n  }, 1 );\n}\n\n\n\n\n(2) Classic\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The current processor identifier is `x`\", with x between 0 and `nProcs` - 1.\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  BSPLib::Classic::ProcId() << std::endl;\n    }, nProcs );\n\n    // prints: \"The current processor identifier is 0\"\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  BSPLib::Classic::ProcId() << std::endl;\n  }, 1 );\n}\n\n\n\n\n(3) BSP\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The current processor identifier is `x`\", with x between 0 and `nProcs` - 1.\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  bsp_pid() << std::endl;\n    }, nProcs );\n\n    // prints: \"The current processor identifier is 0\"\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  bsp_pid() << std::endl;\n  }, 1 );\n}",
            "title": "Processor Identifier"
        },
        {
            "location": "/util/procid/#interfaces",
            "text": "uint32_t BSPLib::ProcId()            // (1) Modern\nuint32_t BSPLib::Classic::ProcId()  // (2) Classic\nuint32_t bsp_pid()                    // (3) BSP  When  BSPLib::Classic::Begin()  has been called, all processors other than the main thread\nwill get a unique identifier assigned in the range  [1, [BSPLib::NProcs() - 1] . The main \nthread holds identifier  0 .   This is interface one should choose to use, and is semantically the same as the other interfaces.  Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.",
            "title": "Interfaces"
        },
        {
            "location": "/util/procid/#return_value",
            "text": "The current processor identifier.",
            "title": "Return Value"
        },
        {
            "location": "/util/procid/#pre-conditions",
            "text": "BSPLib::Classic::Begin()  has been called, otherwise\n  this will return  0xdeadbeef .",
            "title": "Pre-Conditions"
        },
        {
            "location": "/util/procid/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/util/procid/#1_modern",
            "text": "void main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The current processor identifier is `x`\", with x between 0 and `nProcs` - 1.\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  BSPLib::ProcId() << std::endl;\n    }, nProcs );\n\n    // prints: \"The current processor identifier is 0\"\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  BSPLib::ProcId() << std::endl;\n  }, 1 );\n}",
            "title": "(1) Modern"
        },
        {
            "location": "/util/procid/#2_classic",
            "text": "void main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The current processor identifier is `x`\", with x between 0 and `nProcs` - 1.\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  BSPLib::Classic::ProcId() << std::endl;\n    }, nProcs );\n\n    // prints: \"The current processor identifier is 0\"\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  BSPLib::Classic::ProcId() << std::endl;\n  }, 1 );\n}",
            "title": "(2) Classic"
        },
        {
            "location": "/util/procid/#3_bsp",
            "text": "void main( int32_t, const char ** )\n{\n    // The total amount of physical processors available\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The current processor identifier is `x`\", with x between 0 and `nProcs` - 1.\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  bsp_pid() << std::endl;\n    }, nProcs );\n\n    // prints: \"The current processor identifier is 0\"\n    BSPLib::Execute( []\n    {\n        std::cout << \"The current processor identifier is \" <<  bsp_pid() << std::endl;\n  }, 1 );\n}",
            "title": "(3) BSP"
        },
        {
            "location": "/util/time/",
            "text": "Interfaces\n\u00b6\n\n\ndouble BSPLib::Time()            // (1) Modern\ndouble BSPLib::Classic::Time()  // (2) Classic\ndouble bsp_time()                // (3) BSP\n\n\n\n\nGets the time in seconds since for this thread since starting calculations by\ncalling \nBSPLib::Classic::Begin()\n. This function internally\nuses a high precion time, however a good resolution is not guaranteed and may vary\nbetween platforms and compilers. The timings are thread specific, and\nmay vary, due to startup times.\n\n\n\n\nThis is interface one should choose to use, and is semantically the same as the other interfaces.\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\nReturn Value\n\u00b6\n\n\nThe the time in seconds for this processor since the beginning of computation.\n\n\nExamples\n\u00b6\n\n\n(1) Modern\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The processes waited for `x` seconds\", where `x` is greater\n    // than 5 for each thread. \n    BSPLib::Execute( []\n    {\n        std::this_thread::sleep_for( std::chrono::milliseconds( 5000 ) );\n        std::cout << \"The processes waited for \" <<  BSPLib::Time() \n                  << \" seconds\" << std::endl;\n    }, nProcs );\n}\n\n\n\n\n(2) Classic\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The processes waited for `x` seconds\", where `x` is greater\n    // than 5 for each thread. \n    BSPLib::Execute( []\n    {\n        std::this_thread::sleep_for( std::chrono::milliseconds( 5000 ) );\n        std::cout << \"The processes waited for \" <<  BSPLib::Classic::Time() \n                  << \" seconds\" << std::endl;\n    }, nProcs );\n}\n\n\n\n\n(3) BSP\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The processes waited for `x` seconds\", where `x` is greater\n    // than 5 for each thread. \n    BSPLib::Execute( []\n    {\n        std::this_thread::sleep_for( std::chrono::milliseconds( 5000 ) );\n        std::cout << \"The processes waited for \" <<  bsp_sleep() \n                  << \" seconds\" << std::endl;\n    }, nProcs );\n}",
            "title": "Wall Time"
        },
        {
            "location": "/util/time/#interfaces",
            "text": "double BSPLib::Time()            // (1) Modern\ndouble BSPLib::Classic::Time()  // (2) Classic\ndouble bsp_time()                // (3) BSP  Gets the time in seconds since for this thread since starting calculations by\ncalling  BSPLib::Classic::Begin() . This function internally\nuses a high precion time, however a good resolution is not guaranteed and may vary\nbetween platforms and compilers. The timings are thread specific, and\nmay vary, due to startup times.   This is interface one should choose to use, and is semantically the same as the other interfaces.  Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.",
            "title": "Interfaces"
        },
        {
            "location": "/util/time/#return_value",
            "text": "The the time in seconds for this processor since the beginning of computation.",
            "title": "Return Value"
        },
        {
            "location": "/util/time/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/util/time/#1_modern",
            "text": "void main( int32_t, const char ** )\n{\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The processes waited for `x` seconds\", where `x` is greater\n    // than 5 for each thread. \n    BSPLib::Execute( []\n    {\n        std::this_thread::sleep_for( std::chrono::milliseconds( 5000 ) );\n        std::cout << \"The processes waited for \" <<  BSPLib::Time() \n                  << \" seconds\" << std::endl;\n    }, nProcs );\n}",
            "title": "(1) Modern"
        },
        {
            "location": "/util/time/#2_classic",
            "text": "void main( int32_t, const char ** )\n{\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The processes waited for `x` seconds\", where `x` is greater\n    // than 5 for each thread. \n    BSPLib::Execute( []\n    {\n        std::this_thread::sleep_for( std::chrono::milliseconds( 5000 ) );\n        std::cout << \"The processes waited for \" <<  BSPLib::Classic::Time() \n                  << \" seconds\" << std::endl;\n    }, nProcs );\n}",
            "title": "(2) Classic"
        },
        {
            "location": "/util/time/#3_bsp",
            "text": "void main( int32_t, const char ** )\n{\n\n    const uint32_t nProcs = BSPLib::NProcs();\n\n    // prints: \"The processes waited for `x` seconds\", where `x` is greater\n    // than 5 for each thread. \n    BSPLib::Execute( []\n    {\n        std::this_thread::sleep_for( std::chrono::milliseconds( 5000 ) );\n        std::cout << \"The processes waited for \" <<  bsp_sleep() \n                  << \" seconds\" << std::endl;\n    }, nProcs );\n}",
            "title": "(3) BSP"
        },
        {
            "location": "/regdereg/push/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Push( const void *ident, size_t byteSize )         // (1) Modern\nvoid BSPLib::Push()                                             // (2) Padding\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Push( tPrimitive &identRef )                       // (3) Reference\n\ntemplate<>\nvoid BSPLib::Push( std::string &stringRef )                     // (4) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PushPtrs( tPrimitive *begin, size_t count )        // (5) Primitive pointer\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PushPtrs( tPrimitive *begin, tPrimitive *end )     // (6) Primitive pointers\n\ntemplate < typename tIterator>\nvoid BSPLib::PushIterator( tIterator beginIt, size_t count )    // (7) Iterator\n\ntemplate < typename tIterator>\nvoid BSPLib::PushIterator( tIterator beginIt, tIterator endIt ) // (8) Iterators\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::PushCArray( tPrimitive( &cArray )[tSize] )         // (9) C-Array\n\ntemplate< typename tContainer >\nvoid BSPLib::PushContainer( tContainer &container )             // (10) Container\n\n\nvoid BSPLib::Classic::Push( const void *ident, size_t byteSize ) // (11) Classic\nvoid bsp_pushreg( const void *ident, size_t byteSize )           // (12) BSP\n\n\n\n\nPushes a register, with the given size. BSPLib can have communication with any \ncontiguous data type. To ensure this requirement, the library needs to know what\naddresses are available for communication. To recognise addresses of other\nprocessors, the order of \nregistration\n and \nderegistration\n \nneeds to be the same in each processor. When one processor does not need to register\nan address, a \nnullptr\ncan be pushed, or the specialised function (2) can be used.\nEach push should be accompanied by a pop, or is assumed to be popped at the end of\nthe BSP program.\n\n\n\n\nModern interface of the classic BSP function.\n\n\nAdds padding if the current processor does not need to push.\n\n\nPushes a primitive as register. Computes the bytesize internally.\n\n\nTemplate specialisation for \nstd::string\n.\n\n\nPushes the address of \nbegin\n, with bytesize \ncount * sizeof(tPrimitive)\n.\n\n\nPushes all addresses from \nbegin\n to \nend\n. Computes the bytesize internally.\n\n\nPushes the address of the \nbeginIt\n iterator up to \ncount\n adresses more.\n\n\nPushes all addresses from \nbeginIt\n to \nendIt\n. Computes the bytesize internally.\n\n\nPushes all addresses of the C-Array, with bytesize \ntSize * sizeof(tPrimitive)\n.\n\n\nPushes all addresses of the container, with bytesize \ncontainer.size() * sizeof(tContainer::value_type)\n.\n\n\nClassic BSP function.\n\n\nLegacy BSP function.\n\n\n\n\n\n\nWarnings\n\n\n\n\nIn case of (4), the std::string must not be resized. If a resize is absolutely\n   necessary, it should be done before pushing the register, or after popping the\n   register. Also, make sure the processors agree on the size beforehand.\n\n\nIn case of (7), (8) and (10), make sure the iterators describe contiguous memory, \n   and are not invalidated (due to resizes).\n\n\nWhen \nBSPLib::Push()\n is called after \nBSPLib::Pop()\n, the register that has\n   been popped will not be replaced by the new register, as the naming might\n   suggest. \n\n\n\n\n\n\n\n\nNotes\n\n\nIn the current implementation, the pointer to the top of the registration stack\nis never lowered. In the programs we tested until now, this has not been a\nproblem. We might change this behaviour in the future. In case we do, no changes \nwill be needed in existing BSP programs. The stack is always cleared when a new\nBSP program is initialised.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\nident\n The address to register.\n\n\nbyteSize\n The size in bytes of the address space.\n\n\nidentRef\n Reference to the variable to register.\n\n\nstringRef\n Reference to the string to regiser.\n\n\nbegin\n Begin of the address space to register.\n\n\ncount\n Number of addresses to register in the current space.\n\n\nend\n End of the address space to register.\n\n\nbeginIt\n Iterator describing the begin of the address space to register.\n\n\nendIt\n Iterator describing the end of the address space to register.\n\n\ncArray\n C-Array of which we register all addresses.\n\n\ncontainer\n Container of which we register all addresses.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Classic::Begin()\n has been called.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nPush request has been queued.\n\n\nIn the next superstep, this register will be available for \nBSPLib::Put()\n/\nBSPLib::Get()\n.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Modern\n\u00b6\n\n\n(2) Padding\n\u00b6\n\n\n(3) Reference\n\u00b6\n\n\n(4) std::string\n\u00b6\n\n\n(5) Primitive pointer\n\u00b6\n\n\n(6) Primitive pointers\n\u00b6\n\n\n(7) Iterator\n\u00b6\n\n\n(8) Iterators\n\u00b6\n\n\n(9) C-Array\n\u00b6\n\n\n(10) Container\n\u00b6\n\n\n(11) Classic\n\u00b6\n\n\n(12) BSP\n\u00b6",
            "title": "Push Register"
        },
        {
            "location": "/regdereg/push/#interfaces",
            "text": "void BSPLib::Push( const void *ident, size_t byteSize )         // (1) Modern\nvoid BSPLib::Push()                                             // (2) Padding\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Push( tPrimitive &identRef )                       // (3) Reference\n\ntemplate<>\nvoid BSPLib::Push( std::string &stringRef )                     // (4) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PushPtrs( tPrimitive *begin, size_t count )        // (5) Primitive pointer\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PushPtrs( tPrimitive *begin, tPrimitive *end )     // (6) Primitive pointers\n\ntemplate < typename tIterator>\nvoid BSPLib::PushIterator( tIterator beginIt, size_t count )    // (7) Iterator\n\ntemplate < typename tIterator>\nvoid BSPLib::PushIterator( tIterator beginIt, tIterator endIt ) // (8) Iterators\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::PushCArray( tPrimitive( &cArray )[tSize] )         // (9) C-Array\n\ntemplate< typename tContainer >\nvoid BSPLib::PushContainer( tContainer &container )             // (10) Container\n\n\nvoid BSPLib::Classic::Push( const void *ident, size_t byteSize ) // (11) Classic\nvoid bsp_pushreg( const void *ident, size_t byteSize )           // (12) BSP  Pushes a register, with the given size. BSPLib can have communication with any \ncontiguous data type. To ensure this requirement, the library needs to know what\naddresses are available for communication. To recognise addresses of other\nprocessors, the order of  registration  and  deregistration  \nneeds to be the same in each processor. When one processor does not need to register\nan address, a  nullptr can be pushed, or the specialised function (2) can be used.\nEach push should be accompanied by a pop, or is assumed to be popped at the end of\nthe BSP program.   Modern interface of the classic BSP function.  Adds padding if the current processor does not need to push.  Pushes a primitive as register. Computes the bytesize internally.  Template specialisation for  std::string .  Pushes the address of  begin , with bytesize  count * sizeof(tPrimitive) .  Pushes all addresses from  begin  to  end . Computes the bytesize internally.  Pushes the address of the  beginIt  iterator up to  count  adresses more.  Pushes all addresses from  beginIt  to  endIt . Computes the bytesize internally.  Pushes all addresses of the C-Array, with bytesize  tSize * sizeof(tPrimitive) .  Pushes all addresses of the container, with bytesize  container.size() * sizeof(tContainer::value_type) .  Classic BSP function.  Legacy BSP function.    Warnings   In case of (4), the std::string must not be resized. If a resize is absolutely\n   necessary, it should be done before pushing the register, or after popping the\n   register. Also, make sure the processors agree on the size beforehand.  In case of (7), (8) and (10), make sure the iterators describe contiguous memory, \n   and are not invalidated (due to resizes).  When  BSPLib::Push()  is called after  BSPLib::Pop() , the register that has\n   been popped will not be replaced by the new register, as the naming might\n   suggest.      Notes  In the current implementation, the pointer to the top of the registration stack\nis never lowered. In the programs we tested until now, this has not been a\nproblem. We might change this behaviour in the future. In case we do, no changes \nwill be needed in existing BSP programs. The stack is always cleared when a new\nBSP program is initialised.",
            "title": "Interfaces"
        },
        {
            "location": "/regdereg/push/#parameters",
            "text": "ident  The address to register.  byteSize  The size in bytes of the address space.  identRef  Reference to the variable to register.  stringRef  Reference to the string to regiser.  begin  Begin of the address space to register.  count  Number of addresses to register in the current space.  end  End of the address space to register.  beginIt  Iterator describing the begin of the address space to register.  endIt  Iterator describing the end of the address space to register.  cArray  C-Array of which we register all addresses.  container  Container of which we register all addresses.",
            "title": "Parameters"
        },
        {
            "location": "/regdereg/push/#pre-conditions",
            "text": "BSPLib::Classic::Begin()  has been called.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/regdereg/push/#post-conditions",
            "text": "Push request has been queued.  In the next superstep, this register will be available for  BSPLib::Put() / BSPLib::Get() .",
            "title": "Post-Conditions"
        },
        {
            "location": "/regdereg/push/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/regdereg/push/#1_modern",
            "text": "",
            "title": "(1) Modern"
        },
        {
            "location": "/regdereg/push/#2_padding",
            "text": "",
            "title": "(2) Padding"
        },
        {
            "location": "/regdereg/push/#3_reference",
            "text": "",
            "title": "(3) Reference"
        },
        {
            "location": "/regdereg/push/#4_stdstring",
            "text": "",
            "title": "(4) std::string"
        },
        {
            "location": "/regdereg/push/#5_primitive_pointer",
            "text": "",
            "title": "(5) Primitive pointer"
        },
        {
            "location": "/regdereg/push/#6_primitive_pointers",
            "text": "",
            "title": "(6) Primitive pointers"
        },
        {
            "location": "/regdereg/push/#7_iterator",
            "text": "",
            "title": "(7) Iterator"
        },
        {
            "location": "/regdereg/push/#8_iterators",
            "text": "",
            "title": "(8) Iterators"
        },
        {
            "location": "/regdereg/push/#9_c-array",
            "text": "",
            "title": "(9) C-Array"
        },
        {
            "location": "/regdereg/push/#10_container",
            "text": "",
            "title": "(10) Container"
        },
        {
            "location": "/regdereg/push/#11_classic",
            "text": "",
            "title": "(11) Classic"
        },
        {
            "location": "/regdereg/push/#12_bsp",
            "text": "",
            "title": "(12) BSP"
        },
        {
            "location": "/regdereg/pop/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Pop( const void *ident )                       // (1) Modern\nvoid BSPLib::Pop()                                          // (2) Padding\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Pop( tPrimitive &identRef )                    // (3) Reference\n\ntemplate<>\nvoid BSPLib::Pop( std::string &stringRef )                  // (4) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PopPtrs( tPrimitive *begin )                   // (5) Primitive pointer\n\ntemplate < typename tIterator>\nvoid BSPLib::PopIterator( tIterator beginIt )               // (6) Iterator\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::PopCArray( tPrimitive( &cArray )[tSize] )      // (7) C-Array\n\ntemplate< typename tContainer >\nvoid BSPLib::PopContainer( tContainer &container )          // (8) Container\n\nvoid BSPLib::Classic::Pop( const void *ident )              // (9) Classic\nvoid bsp_popreg( const void *ident )                        // (10) BSP\n\n\n\n\nPops a register and makes it unavailable in the next superstep. \nBSPLib can have communication with any \ncontiguous data type. To ensure this requirement, the library needs to know what\naddresses are available for communication. To recognise addresses of other\nprocessors, the order of \nregistration\n and \nderegistration\n \nneeds to be the same in each processor. When one processor does not need to register\nan address, a \nnullptr\ncan be pushed, or the specialised function (2) can be used.\nEach push should be accompanied by a pop, or is assumed to be popped at the end of\nthe BSP program.\n\n\n\n\nModern interface of the classic BSP function.\n\n\nRemoves padding added by \nBSPLib::Push()\n (without parameters).\n\n\nPops the register belonging to a primitive.\n\n\nTemplate specialisation for \nstd::string\n.\n\n\nPops the address of \nbegin\n.\n\n\nPops the address of \nbeginIt\n.\n\n\nPops the addresses of the C-Array.\n\n\nPops the addresses of the container.\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\n\n\nWarnings\n\n\n\n\nIn case of (4), the \nstd::string\n must not have been resized.\n\n\nIn case of (6) and (8), make sure the iterators describe cotiguous memory,\n  and have not been invalidated (due to resizes).\n\n\nWhen \nBSPLib::Push()\n is called after \nBSPLib::Pop()\n, the register that has\n   been popped will not be replaced by the new register, as the naming might\n   suggest. \n\n\n\n\n\n\n\n\nNotes\n\n\nIn the current implementation, the pointer to the top of the registration stack\nis never lowered. In the programs we tested until now, this has not been a\nproblem. We might change this behaviour in the future. In case we do, no changes \nwill be needed in existing BSP programs. The stack is always cleared when a new\nBSP program is initialised.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\nident\n The address to deregister.\n\n\nidentRef\n Reference to the variable to deregister.\n\n\nstringRef\n Reference to the string to deregiser.\n\n\nbegin\n Begin of the address space to deregister.\n\n\nbeginIt\n Iterator describing the begin of the address space to deregister.\n\n\ncArray\n C-Array of which we deregister all addresses.\n\n\ncontainer\n Container of which we deregister all addresses.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Classic::Begin()\n has been called.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nPop request has been queued.\n\n\nIn the next superstep, this register will be unavailable for \nBSPLib::Put()\n/\nBSPLib::Get()\n.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Modern\n\u00b6\n\n\n(2) Padding\n\u00b6\n\n\n(3) Reference\n\u00b6\n\n\n(4) std::string\n\u00b6\n\n\n(5) Primitive pointer\n\u00b6\n\n\n(6) Iterator\n\u00b6\n\n\n(7) C-Array\n\u00b6\n\n\n(8) Container\n\u00b6\n\n\n(9) Classic\n\u00b6\n\n\n(10) BSP\n\u00b6",
            "title": "Pop Register"
        },
        {
            "location": "/regdereg/pop/#interfaces",
            "text": "void BSPLib::Pop( const void *ident )                       // (1) Modern\nvoid BSPLib::Pop()                                          // (2) Padding\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Pop( tPrimitive &identRef )                    // (3) Reference\n\ntemplate<>\nvoid BSPLib::Pop( std::string &stringRef )                  // (4) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PopPtrs( tPrimitive *begin )                   // (5) Primitive pointer\n\ntemplate < typename tIterator>\nvoid BSPLib::PopIterator( tIterator beginIt )               // (6) Iterator\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::PopCArray( tPrimitive( &cArray )[tSize] )      // (7) C-Array\n\ntemplate< typename tContainer >\nvoid BSPLib::PopContainer( tContainer &container )          // (8) Container\n\nvoid BSPLib::Classic::Pop( const void *ident )              // (9) Classic\nvoid bsp_popreg( const void *ident )                        // (10) BSP  Pops a register and makes it unavailable in the next superstep. \nBSPLib can have communication with any \ncontiguous data type. To ensure this requirement, the library needs to know what\naddresses are available for communication. To recognise addresses of other\nprocessors, the order of  registration  and  deregistration  \nneeds to be the same in each processor. When one processor does not need to register\nan address, a  nullptr can be pushed, or the specialised function (2) can be used.\nEach push should be accompanied by a pop, or is assumed to be popped at the end of\nthe BSP program.   Modern interface of the classic BSP function.  Removes padding added by  BSPLib::Push()  (without parameters).  Pops the register belonging to a primitive.  Template specialisation for  std::string .  Pops the address of  begin .  Pops the address of  beginIt .  Pops the addresses of the C-Array.  Pops the addresses of the container.  Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.    Warnings   In case of (4), the  std::string  must not have been resized.  In case of (6) and (8), make sure the iterators describe cotiguous memory,\n  and have not been invalidated (due to resizes).  When  BSPLib::Push()  is called after  BSPLib::Pop() , the register that has\n   been popped will not be replaced by the new register, as the naming might\n   suggest.      Notes  In the current implementation, the pointer to the top of the registration stack\nis never lowered. In the programs we tested until now, this has not been a\nproblem. We might change this behaviour in the future. In case we do, no changes \nwill be needed in existing BSP programs. The stack is always cleared when a new\nBSP program is initialised.",
            "title": "Interfaces"
        },
        {
            "location": "/regdereg/pop/#parameters",
            "text": "ident  The address to deregister.  identRef  Reference to the variable to deregister.  stringRef  Reference to the string to deregiser.  begin  Begin of the address space to deregister.  beginIt  Iterator describing the begin of the address space to deregister.  cArray  C-Array of which we deregister all addresses.  container  Container of which we deregister all addresses.",
            "title": "Parameters"
        },
        {
            "location": "/regdereg/pop/#pre-conditions",
            "text": "BSPLib::Classic::Begin()  has been called.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/regdereg/pop/#post-conditions",
            "text": "Pop request has been queued.  In the next superstep, this register will be unavailable for  BSPLib::Put() / BSPLib::Get() .",
            "title": "Post-Conditions"
        },
        {
            "location": "/regdereg/pop/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/regdereg/pop/#1_modern",
            "text": "",
            "title": "(1) Modern"
        },
        {
            "location": "/regdereg/pop/#2_padding",
            "text": "",
            "title": "(2) Padding"
        },
        {
            "location": "/regdereg/pop/#3_reference",
            "text": "",
            "title": "(3) Reference"
        },
        {
            "location": "/regdereg/pop/#4_stdstring",
            "text": "",
            "title": "(4) std::string"
        },
        {
            "location": "/regdereg/pop/#5_primitive_pointer",
            "text": "",
            "title": "(5) Primitive pointer"
        },
        {
            "location": "/regdereg/pop/#6_iterator",
            "text": "",
            "title": "(6) Iterator"
        },
        {
            "location": "/regdereg/pop/#7_c-array",
            "text": "",
            "title": "(7) C-Array"
        },
        {
            "location": "/regdereg/pop/#8_container",
            "text": "",
            "title": "(8) Container"
        },
        {
            "location": "/regdereg/pop/#9_classic",
            "text": "",
            "title": "(9) Classic"
        },
        {
            "location": "/regdereg/pop/#10_bsp",
            "text": "",
            "title": "(10) BSP"
        },
        {
            "location": "/com/get/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::Get( uint32_t pid, const void *src, ptrdiff_t offset,\n                           void *dst, size_t nbytes )                       // (1) Classic\nvoid bsp_get( uint32_t pid, const void *src, ptrdiff_t offset, void *dst,   \n              size_t nbytes )                                               // (2) Legacy\n\n\n\n\nThis operation get the registered memory of another processor and copies the \nmemory into its own memory. It gets a buffer of size \nnbytes\n from source \npointer \nsrc\n that is located in the processor with identifier \npid\n at \noffset \noffset\n bytes from source pointer \nsrc\n and stores it at the \nlocation of \ndst\n.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to \n   use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards \n   compatibility with other BSP libraries.\n\n\n\n\n\n\nTip\n\n\nThere are easier functions to work with. See for\n\nContainers\n, \nPrimitives\n\nand \nPointers\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The processor identifier of the processor to communicate with.\n\n\nsrc\n Pointer to the source of the information in the other processor.\n\n\noffset\n Offset from the source \nsrc\n in bytes to start reading from.\n\n\ndst\n Pointer to the destination for the information in the current processor.\n\n\nnbytes\n Number of bytes to read.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nsrc != nullptr\n.\n\n\ndst != nullptr\n.\n\n\nBSPLib::Push()\n has been called on \n  \nsrc\n with at least size \noffset + nbytes\n in the processor with ID \npid\n.\n\n\nA \nBSPLib::Sync()\n has happened between \n  \nBSPLig::Push()\n and this call.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nGet request has been queued.\n\n\nIn the next superstep \nBSPLib::Sync()\n, the destination \n  will have the copied value from the source.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\n(2) Legacy\n\u00b6",
            "title": "Normal"
        },
        {
            "location": "/com/get/#interfaces",
            "text": "void BSPLib::Classic::Get( uint32_t pid, const void *src, ptrdiff_t offset,\n                           void *dst, size_t nbytes )                       // (1) Classic\nvoid bsp_get( uint32_t pid, const void *src, ptrdiff_t offset, void *dst,   \n              size_t nbytes )                                               // (2) Legacy  This operation get the registered memory of another processor and copies the \nmemory into its own memory. It gets a buffer of size  nbytes  from source \npointer  src  that is located in the processor with identifier  pid  at \noffset  offset  bytes from source pointer  src  and stores it at the \nlocation of  dst .   Classic BSP function, this is the interface one should prefer to \n   use over the old BSP interface.  Legacy BSP function, this interface is included for backwards \n   compatibility with other BSP libraries.    Tip  There are easier functions to work with. See for Containers ,  Primitives \nand  Pointers .",
            "title": "Interfaces"
        },
        {
            "location": "/com/get/#parameters",
            "text": "pid  The processor identifier of the processor to communicate with.  src  Pointer to the source of the information in the other processor.  offset  Offset from the source  src  in bytes to start reading from.  dst  Pointer to the destination for the information in the current processor.  nbytes  Number of bytes to read.",
            "title": "Parameters"
        },
        {
            "location": "/com/get/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  src != nullptr .  dst != nullptr .  BSPLib::Push()  has been called on \n   src  with at least size  offset + nbytes  in the processor with ID  pid .  A  BSPLib::Sync()  has happened between \n   BSPLig::Push()  and this call.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/com/get/#post-conditions",
            "text": "Get request has been queued.  In the next superstep  BSPLib::Sync() , the destination \n  will have the copied value from the source.",
            "title": "Post-Conditions"
        },
        {
            "location": "/com/get/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/com/get/#1_classic",
            "text": "",
            "title": "(1) Classic"
        },
        {
            "location": "/com/get/#2_legacy",
            "text": "",
            "title": "(2) Legacy"
        },
        {
            "location": "/com/getPrimitive/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Get( uint32_t pid, tPrimitive &src, tPrimitive &dst )      // (1) References\n\ntemplate<>\nvoid BSPLib::Get( uint32_t pid, std::string &src, std::string &dst )    // (2) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Get( uint32_t pid, tPrimitive &var )                       // (3) Reference\n\n\n\n\nThis operation get the registered primitive of another processor and copies the \nmemory into its own memory. It gets the primitive stored in \nsrc\n that \nis located in the processor with ID \npid\n and stores it at the location of \ndst\n. \nInternally, it calculates the size in bytes that is required for the primitive, \nand calls to \nBSPLib::Classic::Get()\n.\n\n\n\n\nGets the value from \nsrc\n in the processor with ID \npid\n and stores \n   it in \ndst\n, using references.\n\n\nOverload for \nstd::string\n.\n\n\nGet the value from \nvar\n in the processor with ID \npid\n and \n   stores it in \nvar\n, the same reference.\n\n\n\n\n\n\nTip\n\n\nThere are also other specialisations available. See\n\nContainers\n, \nPrimitives\n\nand \nPointers\n.\n\n\n\n\n\n\nWarnings\n\n\n\n\nIn case of (2), the destination \nstd::string\n must be at least as big \n   as the source \nstd::string\n. Make sure it is correctly resized, \n   either by deciding on a fixed size, or communicating the size beforehand.\n\n\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The identifier of the processor to communicate with.\n\n\nsrc\n Reference to the source of the information in the other processor.\n\n\ndst\n Reference to the destination for the information in the current processor.\n\n\nvar\n Reference to both the source of the in the other processor, and the \n  destination for the information in the current processor.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nBSPLib::Push()\n has been called on \nsrc\n in the processor with ID \npid\n.\n\n\nA \nBSPLib::Sync()\n has happened between \nBSPLig::Push()\n and this call.\n\n\nIn case of (2), the \ndst\n string is at least as big as the \nsrc\n string.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nGet request has been queued.\n\n\nIn the next superstep \nBSPLib::Sync()\n, the destination \n  will have the copied value from the source.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) References\n\u00b6\n\n\n(2) std::string\n\u00b6\n\n\n(3) Reference\n\u00b6",
            "title": "Primitives"
        },
        {
            "location": "/com/getPrimitive/#interfaces",
            "text": "template< typename tPrimitive >\nvoid BSPLib::Get( uint32_t pid, tPrimitive &src, tPrimitive &dst )      // (1) References\n\ntemplate<>\nvoid BSPLib::Get( uint32_t pid, std::string &src, std::string &dst )    // (2) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Get( uint32_t pid, tPrimitive &var )                       // (3) Reference  This operation get the registered primitive of another processor and copies the \nmemory into its own memory. It gets the primitive stored in  src  that \nis located in the processor with ID  pid  and stores it at the location of  dst . \nInternally, it calculates the size in bytes that is required for the primitive, \nand calls to  BSPLib::Classic::Get() .   Gets the value from  src  in the processor with ID  pid  and stores \n   it in  dst , using references.  Overload for  std::string .  Get the value from  var  in the processor with ID  pid  and \n   stores it in  var , the same reference.    Tip  There are also other specialisations available. See Containers ,  Primitives \nand  Pointers .    Warnings   In case of (2), the destination  std::string  must be at least as big \n   as the source  std::string . Make sure it is correctly resized, \n   either by deciding on a fixed size, or communicating the size beforehand.",
            "title": "Interfaces"
        },
        {
            "location": "/com/getPrimitive/#parameters",
            "text": "pid  The identifier of the processor to communicate with.  src  Reference to the source of the information in the other processor.  dst  Reference to the destination for the information in the current processor.  var  Reference to both the source of the in the other processor, and the \n  destination for the information in the current processor.",
            "title": "Parameters"
        },
        {
            "location": "/com/getPrimitive/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  BSPLib::Push()  has been called on  src  in the processor with ID  pid .  A  BSPLib::Sync()  has happened between  BSPLig::Push()  and this call.  In case of (2), the  dst  string is at least as big as the  src  string.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/com/getPrimitive/#post-conditions",
            "text": "Get request has been queued.  In the next superstep  BSPLib::Sync() , the destination \n  will have the copied value from the source.",
            "title": "Post-Conditions"
        },
        {
            "location": "/com/getPrimitive/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/com/getPrimitive/#1_references",
            "text": "",
            "title": "(1) References"
        },
        {
            "location": "/com/getPrimitive/#2_stdstring",
            "text": "",
            "title": "(2) std::string"
        },
        {
            "location": "/com/getPrimitive/#3_reference",
            "text": "",
            "title": "(3) Reference"
        },
        {
            "location": "/com/getPtrs/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *srcBegin, size_t offset,\n              tPrimitive *resultBegin, size_t count )           // (1) Begin-Offset-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *srcBegin, tPrimitive *srcCursor, \n              tPrimitive *resultBegin, tPrimitive *resultEnd )  // (2) Begin-End-Cursor\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *begin,\n                      tPrimitive *cursor, tPrimitive *end ) // (3) Same Begin-End-Cursor\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *begin, \n                      tPrimitive *end )                     // (4) Same Begin-End\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *begin,\n                      size_t offset, size_t count )         // (5) Same Begin-Offset-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *begin,\n                      size_t count )                        // (6) Same Begin-Count\n\n\n\n\nThis operation get the registered memory of another processor and copies the \nmemory into its own memory. Gets a buffer of size \ncount\n primitives from \nsource pointer \nsrcBegin\n that is located in the processor with identifier \npid\n \nat offset \noffset\n primitives from source pointer \nsrc\n and stores it \nat the location of \ndstBegin\n.\n\n\n\n\nGets a buffer of size \ncount\n primitives from source pointer \nsrcBegin\n \n   that is located in the processor with ID \npid\n at offset \noffset\n \n   primitives from source pointer \nsrc\n and stores it at the location of \ndstBegin\n.\n\n\nUses \nresultBegin\n and \nresultEnd\n pointers to calculate the number \n   of primitives \ncount\n, and uses \nsrcCursor\n instead of \noffset\n\n   to determine the offset it needs to start reading from.\n\n\nThe same as (1), but now, it uses \nbegin\n as \nsrcBegin\n, \ncursor\n as \n   both \nsrcCursor\n and \nresultBegin\n, and \nend\n as \nresultEnd\n.\n   It stores the values in the same location as they were located in the \n   other processor.\n\n\nThe same as (3), but now \nbegin\n is used as both \nbegin\n and \ncursor\n. \n   It copies the entire range from \nbegin\n to \nend\n from the\n   processor with ID \npid\n to the same location in the current processor.\n\n\nThe same as (3), with the behaviour: \ncursor = begin + offset\n and \n   \nend = begin + offset + count\n.\n\n\nThe same as (5), with the behaviour: \noffset = 0\n.\n\n\n\n\n\n\nTip\n\n\nThere are also other specialisations available. See\n\nContainers\n, \nPrimitives\n\nand \nPointers\n.\n\n\n\n\n\n\nWarnings\n\n\n\n\nstd::string\n is not assumed to be a primitive in this case, \n   although it was in \nBSPLib::Get()\n.\n\n\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to communicate with.\n\n\nsrcBegin\n Pointer to the begin of the information in the other processor.\n\n\noffset\n Offset from the source \nsrcBegin\n in number of primitives to \n  start reading from.\n\n\nresultBegin\n Pointer to the destination for the information in the \n  current processor.\n\n\ncount\n Number of primitives to read.\n\n\nsrcCursor\n Other method to determine \noffset\n. The behaviour is the \n  same as taking \noffset = srcCursor - srcBegin\n.\n\n\nresultEnd\n Other method to determine \ncount\n. The behaviour is the \n  same as taking \ncount = resultEnd - resultBegin\n.\n\n\nbegin\n Pointer to the begin of the information in both the processors.\n\n\ncursor\n Cursor to start reading from in the other processor, and to \n   start writing to in the current processor.\n\n\nend\n End of the information block to get.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nNone of the pointers \nsrcBegin\n, \nresultBegin\n, \nsrcCursor\n, \nbegin\n, \n  \ncursor\n and \nend\n is allowed to be \nnullptr\n. \n\n\nBSPLib::Push()\n has been called on \nsrcBegin\n or \n  \nbegin\n with at least size \noffset + nbytes\n in the processor with ID \npid\n.\n\n\nA \nBSPLib::Sync()\n has happened between \n  \nBSPLig::Push()\n and this call.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nGet request has been queued.\n\n\nIn the next superstep \nBSPLib::Sync()\n, the destination \n  will have the copied value from the source.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Begin-Offset-Count\n\u00b6\n\n\n(2) Begin-End-Cursor\n\u00b6\n\n\n(3) Same Begin-End-Cursor\n\u00b6\n\n\n(4) Same Begin-End\n\u00b6\n\n\n(5) Same Begin-Offset-Count\n\u00b6\n\n\n(6) Same Begin-Count\n\u00b6",
            "title": "Pointers"
        },
        {
            "location": "/com/getPtrs/#interfaces",
            "text": "template< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *srcBegin, size_t offset,\n              tPrimitive *resultBegin, size_t count )           // (1) Begin-Offset-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *srcBegin, tPrimitive *srcCursor, \n              tPrimitive *resultBegin, tPrimitive *resultEnd )  // (2) Begin-End-Cursor\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *begin,\n                      tPrimitive *cursor, tPrimitive *end ) // (3) Same Begin-End-Cursor\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *begin, \n                      tPrimitive *end )                     // (4) Same Begin-End\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *begin,\n                      size_t offset, size_t count )         // (5) Same Begin-Offset-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetPtrs( uint32_t pid, tPrimitive *begin,\n                      size_t count )                        // (6) Same Begin-Count  This operation get the registered memory of another processor and copies the \nmemory into its own memory. Gets a buffer of size  count  primitives from \nsource pointer  srcBegin  that is located in the processor with identifier  pid  \nat offset  offset  primitives from source pointer  src  and stores it \nat the location of  dstBegin .   Gets a buffer of size  count  primitives from source pointer  srcBegin  \n   that is located in the processor with ID  pid  at offset  offset  \n   primitives from source pointer  src  and stores it at the location of  dstBegin .  Uses  resultBegin  and  resultEnd  pointers to calculate the number \n   of primitives  count , and uses  srcCursor  instead of  offset \n   to determine the offset it needs to start reading from.  The same as (1), but now, it uses  begin  as  srcBegin ,  cursor  as \n   both  srcCursor  and  resultBegin , and  end  as  resultEnd .\n   It stores the values in the same location as they were located in the \n   other processor.  The same as (3), but now  begin  is used as both  begin  and  cursor . \n   It copies the entire range from  begin  to  end  from the\n   processor with ID  pid  to the same location in the current processor.  The same as (3), with the behaviour:  cursor = begin + offset  and \n    end = begin + offset + count .  The same as (5), with the behaviour:  offset = 0 .    Tip  There are also other specialisations available. See Containers ,  Primitives \nand  Pointers .    Warnings   std::string  is not assumed to be a primitive in this case, \n   although it was in  BSPLib::Get() .",
            "title": "Interfaces"
        },
        {
            "location": "/com/getPtrs/#parameters",
            "text": "pid  The ID of the processor to communicate with.  srcBegin  Pointer to the begin of the information in the other processor.  offset  Offset from the source  srcBegin  in number of primitives to \n  start reading from.  resultBegin  Pointer to the destination for the information in the \n  current processor.  count  Number of primitives to read.  srcCursor  Other method to determine  offset . The behaviour is the \n  same as taking  offset = srcCursor - srcBegin .  resultEnd  Other method to determine  count . The behaviour is the \n  same as taking  count = resultEnd - resultBegin .  begin  Pointer to the begin of the information in both the processors.  cursor  Cursor to start reading from in the other processor, and to \n   start writing to in the current processor.  end  End of the information block to get.",
            "title": "Parameters"
        },
        {
            "location": "/com/getPtrs/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  None of the pointers  srcBegin ,  resultBegin ,  srcCursor ,  begin , \n   cursor  and  end  is allowed to be  nullptr .   BSPLib::Push()  has been called on  srcBegin  or \n   begin  with at least size  offset + nbytes  in the processor with ID  pid .  A  BSPLib::Sync()  has happened between \n   BSPLig::Push()  and this call.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/com/getPtrs/#post-conditions",
            "text": "Get request has been queued.  In the next superstep  BSPLib::Sync() , the destination \n  will have the copied value from the source.",
            "title": "Post-Conditions"
        },
        {
            "location": "/com/getPtrs/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/com/getPtrs/#1_begin-offset-count",
            "text": "",
            "title": "(1) Begin-Offset-Count"
        },
        {
            "location": "/com/getPtrs/#2_begin-end-cursor",
            "text": "",
            "title": "(2) Begin-End-Cursor"
        },
        {
            "location": "/com/getPtrs/#3_same_begin-end-cursor",
            "text": "",
            "title": "(3) Same Begin-End-Cursor"
        },
        {
            "location": "/com/getPtrs/#4_same_begin-end",
            "text": "",
            "title": "(4) Same Begin-End"
        },
        {
            "location": "/com/getPtrs/#5_same_begin-offset-count",
            "text": "",
            "title": "(5) Same Begin-Offset-Count"
        },
        {
            "location": "/com/getPtrs/#6_same_begin-count",
            "text": "",
            "title": "(6) Same Begin-Count"
        },
        {
            "location": "/com/getContainer/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tIterator, typename tOutputIterator >\n    void GetIterator( uint32_t pid, tIterator srcBegin, size_t offset, \n                      tOutputIterator resultBegin, \n                      size_t count )                            // (1) Begin-Offset-Count\n\ntemplate< typename tIterator, typename tOutputIterator >\nvoid BSPLib::GetIterator( uint32_t pid, tIterator srcBegin, tIterator srcCursor, \n                          tOutputIterator resultBegin,\n                          tOutputIterator resultEnd )           // (2) Begin-Cursor-End\n\ntemplate< typename tIterator >\nvoid BSPLib::GetIterator( uint32_t pid, tIterator begin, \n                          tIterator cursor, tIterator end )     // (3) Same Begin-Cursor-End\n\ntemplate< typename tIterator >\nvoid BSPLib::GetIterator( uint32_t pid, tIterator begin, \n                          tIterator end )                       // (4) Same Begin-End\n\ntemplate< typename tIterator >\nvoid BSPLib::GetIterator( uint32_t pid, tIterator begin,\n                          size_t offset, size_t count )         // (5) Same Begin-Offset-Count\n\ntemplate< typename tPrimitive, size_t tSizeIn, size_t tSizeOut >\nvoid BSPLib::GetCArray( uint32_t pid, tPrimitive( &srcCArray )[tSizeIn], \n                        tPrimitive( &dstCArray )[tSizeOut] )    // (6) C-Array\n\ntemplate< typename tPrimitive, size_t tSizeIn, size_t tSizeOut >\nvoid BSPLib::GetCArray( uint32_t pid, \n                        tPrimitive( &cArray )[tSizeIn] )        // (7) Same C-Array\n\ntemplate < typename tContainerIn, typename tContainerOut >\nvoid BSPLib::GetContainer( uint32_t pid, tContainerIn &srcContainer,\n                           tContainerOut &dstContainer )        // (8) General container   \n\ntemplate < typename tContainerIn, typename tContainerOut >\nvoid BSPLib::GetContainer( uint32_t pid,\n                           tContainer &srcContainer )           // (9) Same container\n\n\n\n\nThis operation get the registered memory of another processor and copies the \nmemory into its own memory. Gets the values from the container in the processor \nwith identifier \npid\n and stores it the required destination container. \nInternally, it calculates the size in bytes that is required for the primitive, \nand calls to \nBSPLib::Classic::Get()\n.\n\n\n\n\nGets a buffer of size \ncount\n primitives from source iterator \n   \nsrcBegin\n that is located in the processor with identifier \npid\n at \n   offset \noffset\n primitives from source iterator \nsrcBegin\n and stores \n   it at the location of \ndstBegin\n.\n\n\nHas the same behaviour as (1), but now we use a cursor\n   instead of a count. The offset is defined as \noffset = srcCursor - srcBegin\n \n   and \ncount = resultEnd - resultBegin\n.\n\n\nHas the same behaviour as (1), using that \nsrcBegin = begin\n, \n   \nsrcCursor = resultBegin = cursor\n and \nresultEnd = end\n.\n\n\nHas the same behaviour as (3), using that \ncursor = begin\n.\n\n\nHas the same behaviour as (1), using that \nsrcBegin = resultBegin = begin\n.\n\n\nGets an entire C-Array as buffer from \nsrcCArray\n located in the processor \n   with identifier \npid\n and stores it at the location of \ndstCArray\n.\n\n\nHas the same behaviour as (6), but now \nsrcCArray = dstCArray = cArray\n, \n   so the source is in the same location as the destination, but in the \n   other processor.\n\n\nGets an entire container as buffer from \nsrcContainer\n located in the \n   processor with identifier \npid\n and stores it at the location of \ndstContainer\n.\n\n\nHas the same behaviour as (8), but now \nsrcContainer = dstContainer = container\n.\n\n\n\n\n\n\nWarnings\n\n\n\n\nIn case of (8) and (9), make sure the container is described by contiguous \n   iterators.\n\n\n\n\n\n\n\n\nTip\n\n\nThere are also other specialisations available. See\n\nContainers\n, \nPrimitives\n\nand \nPointers\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The identifier of the processor to communicate with.\n\n\nsrcBegin\n Iterator describing the begin of the information in the other processor.\n\n\noffset\n Offset from the source \nsrcBegin\n in number of primitives to start \n  reading from.\n\n\nresultBegin\n Iterator describing the destination for the information in \n  the current processor.\n\n\ncount\n Number of primitives to read.\n\n\nsrcCursor\n Other method to determine \noffset\n. The behaviour is the same as \n  taking \noffset = srcCursor - srcBegin\n.\n\n\nresultEnd\n Other method to determine \ncount\n. The behaviour is the same as\n  taking \ncount = resultEnd - resultBegin\n.\n\n\nbegin\n Iterator describing the begin of the information in both the processors.\n\n\ncursor\n Cursor to start reading from in the other processor, and to start writing\n  to in the current processor.\n\n\nend\n End of the information block to get.\n\n\nsrcCArray\n C-Array located in the other processor, the source of the information.\n\n\ndstCArray\n C-Array located in the current processor, the destination for \n  the information.\n\n\ncArray\n C-Array that is located in both the processors, both the source \n  and the destination for the information.\n\n\nsrcContainer\n Container located in the other processor, the source of \n  the information.\n\n\ndstContainer\n Container located in the current processor, the destination \n  for the information.\n\n\ncontainer\n Container that is located in both the processors, both the source \n  and the destination for the information.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nBSPLib::Push()\n has been called on the source,\n  in the processor with identifier \npid\n, with at least the same size as the destination.\n\n\nA \nBSPLib::Sync()\n has happened between \n  \nBSPLig::Push()\n and this call.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nGet request has been queued.\n\n\nIn the next superstep \nBSPLib::Sync()\n, the destination \n  will have the copied value from the source.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Begin-Offset-Count\n\u00b6\n\n\n(2) Begin-Cursor-End\n\u00b6\n\n\n(3) Same Begin-Cursor-End\n\u00b6\n\n\n(4) Same Begin-End\n\u00b6\n\n\n(5) Same Begin-Offset-Count\n\u00b6\n\n\n(6) C-Array\n\u00b6\n\n\n(7) Same C-Array\n\u00b6\n\n\n(8) General container\n\u00b6\n\n\n(9) Same container\n\u00b6",
            "title": "Containers"
        },
        {
            "location": "/com/getContainer/#interfaces",
            "text": "template< typename tIterator, typename tOutputIterator >\n    void GetIterator( uint32_t pid, tIterator srcBegin, size_t offset, \n                      tOutputIterator resultBegin, \n                      size_t count )                            // (1) Begin-Offset-Count\n\ntemplate< typename tIterator, typename tOutputIterator >\nvoid BSPLib::GetIterator( uint32_t pid, tIterator srcBegin, tIterator srcCursor, \n                          tOutputIterator resultBegin,\n                          tOutputIterator resultEnd )           // (2) Begin-Cursor-End\n\ntemplate< typename tIterator >\nvoid BSPLib::GetIterator( uint32_t pid, tIterator begin, \n                          tIterator cursor, tIterator end )     // (3) Same Begin-Cursor-End\n\ntemplate< typename tIterator >\nvoid BSPLib::GetIterator( uint32_t pid, tIterator begin, \n                          tIterator end )                       // (4) Same Begin-End\n\ntemplate< typename tIterator >\nvoid BSPLib::GetIterator( uint32_t pid, tIterator begin,\n                          size_t offset, size_t count )         // (5) Same Begin-Offset-Count\n\ntemplate< typename tPrimitive, size_t tSizeIn, size_t tSizeOut >\nvoid BSPLib::GetCArray( uint32_t pid, tPrimitive( &srcCArray )[tSizeIn], \n                        tPrimitive( &dstCArray )[tSizeOut] )    // (6) C-Array\n\ntemplate< typename tPrimitive, size_t tSizeIn, size_t tSizeOut >\nvoid BSPLib::GetCArray( uint32_t pid, \n                        tPrimitive( &cArray )[tSizeIn] )        // (7) Same C-Array\n\ntemplate < typename tContainerIn, typename tContainerOut >\nvoid BSPLib::GetContainer( uint32_t pid, tContainerIn &srcContainer,\n                           tContainerOut &dstContainer )        // (8) General container   \n\ntemplate < typename tContainerIn, typename tContainerOut >\nvoid BSPLib::GetContainer( uint32_t pid,\n                           tContainer &srcContainer )           // (9) Same container  This operation get the registered memory of another processor and copies the \nmemory into its own memory. Gets the values from the container in the processor \nwith identifier  pid  and stores it the required destination container. \nInternally, it calculates the size in bytes that is required for the primitive, \nand calls to  BSPLib::Classic::Get() .   Gets a buffer of size  count  primitives from source iterator \n    srcBegin  that is located in the processor with identifier  pid  at \n   offset  offset  primitives from source iterator  srcBegin  and stores \n   it at the location of  dstBegin .  Has the same behaviour as (1), but now we use a cursor\n   instead of a count. The offset is defined as  offset = srcCursor - srcBegin  \n   and  count = resultEnd - resultBegin .  Has the same behaviour as (1), using that  srcBegin = begin , \n    srcCursor = resultBegin = cursor  and  resultEnd = end .  Has the same behaviour as (3), using that  cursor = begin .  Has the same behaviour as (1), using that  srcBegin = resultBegin = begin .  Gets an entire C-Array as buffer from  srcCArray  located in the processor \n   with identifier  pid  and stores it at the location of  dstCArray .  Has the same behaviour as (6), but now  srcCArray = dstCArray = cArray , \n   so the source is in the same location as the destination, but in the \n   other processor.  Gets an entire container as buffer from  srcContainer  located in the \n   processor with identifier  pid  and stores it at the location of  dstContainer .  Has the same behaviour as (8), but now  srcContainer = dstContainer = container .    Warnings   In case of (8) and (9), make sure the container is described by contiguous \n   iterators.     Tip  There are also other specialisations available. See Containers ,  Primitives \nand  Pointers .",
            "title": "Interfaces"
        },
        {
            "location": "/com/getContainer/#parameters",
            "text": "pid  The identifier of the processor to communicate with.  srcBegin  Iterator describing the begin of the information in the other processor.  offset  Offset from the source  srcBegin  in number of primitives to start \n  reading from.  resultBegin  Iterator describing the destination for the information in \n  the current processor.  count  Number of primitives to read.  srcCursor  Other method to determine  offset . The behaviour is the same as \n  taking  offset = srcCursor - srcBegin .  resultEnd  Other method to determine  count . The behaviour is the same as\n  taking  count = resultEnd - resultBegin .  begin  Iterator describing the begin of the information in both the processors.  cursor  Cursor to start reading from in the other processor, and to start writing\n  to in the current processor.  end  End of the information block to get.  srcCArray  C-Array located in the other processor, the source of the information.  dstCArray  C-Array located in the current processor, the destination for \n  the information.  cArray  C-Array that is located in both the processors, both the source \n  and the destination for the information.  srcContainer  Container located in the other processor, the source of \n  the information.  dstContainer  Container located in the current processor, the destination \n  for the information.  container  Container that is located in both the processors, both the source \n  and the destination for the information.",
            "title": "Parameters"
        },
        {
            "location": "/com/getContainer/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  BSPLib::Push()  has been called on the source,\n  in the processor with identifier  pid , with at least the same size as the destination.  A  BSPLib::Sync()  has happened between \n   BSPLig::Push()  and this call.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/com/getContainer/#post-conditions",
            "text": "Get request has been queued.  In the next superstep  BSPLib::Sync() , the destination \n  will have the copied value from the source.",
            "title": "Post-Conditions"
        },
        {
            "location": "/com/getContainer/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/com/getContainer/#1_begin-offset-count",
            "text": "",
            "title": "(1) Begin-Offset-Count"
        },
        {
            "location": "/com/getContainer/#2_begin-cursor-end",
            "text": "",
            "title": "(2) Begin-Cursor-End"
        },
        {
            "location": "/com/getContainer/#3_same_begin-cursor-end",
            "text": "",
            "title": "(3) Same Begin-Cursor-End"
        },
        {
            "location": "/com/getContainer/#4_same_begin-end",
            "text": "",
            "title": "(4) Same Begin-End"
        },
        {
            "location": "/com/getContainer/#5_same_begin-offset-count",
            "text": "",
            "title": "(5) Same Begin-Offset-Count"
        },
        {
            "location": "/com/getContainer/#6_c-array",
            "text": "",
            "title": "(6) C-Array"
        },
        {
            "location": "/com/getContainer/#7_same_c-array",
            "text": "",
            "title": "(7) Same C-Array"
        },
        {
            "location": "/com/getContainer/#8_general_container",
            "text": "",
            "title": "(8) General container"
        },
        {
            "location": "/com/getContainer/#9_same_container",
            "text": "",
            "title": "(9) Same container"
        },
        {
            "location": "/com/put/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::Put( uint32_t pid, const void *src, void *dst, ptrdiff_t offset,\n                           size_t nbytes )                                  // (1) Classic\nvoid bsp_get( uint32_t pid, const void *src, void *dst, ptrdiff_t offset,\n              size_t nbytes )                                               // (2) Legacy\n\n\n\n\nPuts a buffer of size \nnbytes\n from source pointer \nsrc\n in the thread \nwith identifier \npid\n at offset \noffset\n from destination pointer \ndst\n.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to \n   use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards \n   compatibility with other BSP libraries.\n\n\n\n\n\n\nTip\n\n\nThere are easier functions to work with. See for\n\nContainers\n, \nPrimitives\n\nand \nPointers\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to communicate with.\n\n\nsrc\n Pointer to the source of the information in the current processor.\n\n\noffset\n Offset from the destination \ndst\n in bytes to start writing from.\n\n\ndst\n Pointer to the destination for the information in the other processor.\n\n\nnbytes\n Number of bytes to write.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nsrc != nullptr\n.\n\n\ndst != nullptr\n.\n\n\nBSPLib::Push()\n has been called on \ndst\n \n  with at leas size \noffset + nbytes\n in the processor with identifier \npid\n.\n\n\nA \nBSPLib::Sync()\n has happened between \n  \nBSPLig::Push()\n and this call.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nPut request has been queued.\n\n\nIn the next superstep \nBSPLib::Sync()\n, the destination \n  will have the copied value from the source.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\n(2) Legacy\n\u00b6",
            "title": "Normal"
        },
        {
            "location": "/com/put/#interfaces",
            "text": "void BSPLib::Classic::Put( uint32_t pid, const void *src, void *dst, ptrdiff_t offset,\n                           size_t nbytes )                                  // (1) Classic\nvoid bsp_get( uint32_t pid, const void *src, void *dst, ptrdiff_t offset,\n              size_t nbytes )                                               // (2) Legacy  Puts a buffer of size  nbytes  from source pointer  src  in the thread \nwith identifier  pid  at offset  offset  from destination pointer  dst .   Classic BSP function, this is the interface one should prefer to \n   use over the old BSP interface.  Legacy BSP function, this interface is included for backwards \n   compatibility with other BSP libraries.    Tip  There are easier functions to work with. See for Containers ,  Primitives \nand  Pointers .",
            "title": "Interfaces"
        },
        {
            "location": "/com/put/#parameters",
            "text": "pid  The ID of the processor to communicate with.  src  Pointer to the source of the information in the current processor.  offset  Offset from the destination  dst  in bytes to start writing from.  dst  Pointer to the destination for the information in the other processor.  nbytes  Number of bytes to write.",
            "title": "Parameters"
        },
        {
            "location": "/com/put/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  src != nullptr .  dst != nullptr .  BSPLib::Push()  has been called on  dst  \n  with at leas size  offset + nbytes  in the processor with identifier  pid .  A  BSPLib::Sync()  has happened between \n   BSPLig::Push()  and this call.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/com/put/#post-conditions",
            "text": "Put request has been queued.  In the next superstep  BSPLib::Sync() , the destination \n  will have the copied value from the source.",
            "title": "Post-Conditions"
        },
        {
            "location": "/com/put/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/com/put/#1_classic",
            "text": "",
            "title": "(1) Classic"
        },
        {
            "location": "/com/put/#2_legacy",
            "text": "",
            "title": "(2) Legacy"
        },
        {
            "location": "/com/putPrimitive/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Put( uint32_t pid, tPrimitive &src, tPrimitive &dst )      // (1) References\n\ntemplate<>\nvoid BSPLib::Put( uint32_t pid, std::string &src, std::string &dst )    // (2) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Put( uint32_t pid, tPrimitive &var )                       // (3) Reference\n\n\n\n\nPuts the primitive stored in \nsrc\n that is located in the current processor\nand stores it at the location of \ndst\n that is located in the processor with \nidentifier \npid\n. Internally, it calculates the size in bytes that is required \nfor the primitive, and calls to \nBSPLib::Classic::Put()\n.\n\n\n\n\nPuts the value from \nsrc\n and stores it in \ndst\n in the processor \n   with identifier \npid\n, using references.\n\n\nOverload for \nstd::string\n.\n\n\nPut the value from \nvar\n and stores it in \nvar\nin the processor with \n   identifier \npid\n, the same reference.\n\n\n\n\n\n\nTip\n\n\nThere are also other specialisations available. See\n\nContainers\n, \nPrimitives\n\nand \nPointers\n.\n\n\n\n\n\n\nWarnings\n\n\n\n\nIn case of (2), the destination \nstd::string\n must be at least \n   as big as the source \nstd::string\n. Make sure it is correctly resized, \n   either by deciding on a fixed size, or communicating the size beforehand.\n\n\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The identifier of the processor to communicate with.\n\n\nsrc\n Reference to the source of the information in the current processor.\n\n\ndst\n Reference to the destination for the information in the other processor.\n\n\nvar\n Reference to both the source of the in the current processor, and the \n        destination for the information in the other processor.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nBSPLib::Push()\n has been called on \ndst\n in the \n  processor with identifier \npid\n.\n\n\nA \nBSPLib::Sync()\n has happened between \n  \nBSPLig::Push()\n and this call.\n\n\nIn case of (2), the \ndst\n string is at least as big as the \nsrc\n string.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nPut request has been queued.\n\n\nIn the next superstep \nBSPLib::Sync()\n, \n  the destination will have the copied value from the source.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) References\n\u00b6\n\n\n(2) std::string\n\u00b6\n\n\n(3) Reference\n\u00b6",
            "title": "Primitives"
        },
        {
            "location": "/com/putPrimitive/#interfaces",
            "text": "template< typename tPrimitive >\nvoid BSPLib::Put( uint32_t pid, tPrimitive &src, tPrimitive &dst )      // (1) References\n\ntemplate<>\nvoid BSPLib::Put( uint32_t pid, std::string &src, std::string &dst )    // (2) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Put( uint32_t pid, tPrimitive &var )                       // (3) Reference  Puts the primitive stored in  src  that is located in the current processor\nand stores it at the location of  dst  that is located in the processor with \nidentifier  pid . Internally, it calculates the size in bytes that is required \nfor the primitive, and calls to  BSPLib::Classic::Put() .   Puts the value from  src  and stores it in  dst  in the processor \n   with identifier  pid , using references.  Overload for  std::string .  Put the value from  var  and stores it in  var in the processor with \n   identifier  pid , the same reference.    Tip  There are also other specialisations available. See Containers ,  Primitives \nand  Pointers .    Warnings   In case of (2), the destination  std::string  must be at least \n   as big as the source  std::string . Make sure it is correctly resized, \n   either by deciding on a fixed size, or communicating the size beforehand.",
            "title": "Interfaces"
        },
        {
            "location": "/com/putPrimitive/#parameters",
            "text": "pid  The identifier of the processor to communicate with.  src  Reference to the source of the information in the current processor.  dst  Reference to the destination for the information in the other processor.  var  Reference to both the source of the in the current processor, and the \n        destination for the information in the other processor.",
            "title": "Parameters"
        },
        {
            "location": "/com/putPrimitive/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  BSPLib::Push()  has been called on  dst  in the \n  processor with identifier  pid .  A  BSPLib::Sync()  has happened between \n   BSPLig::Push()  and this call.  In case of (2), the  dst  string is at least as big as the  src  string.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/com/putPrimitive/#post-conditions",
            "text": "Put request has been queued.  In the next superstep  BSPLib::Sync() , \n  the destination will have the copied value from the source.",
            "title": "Post-Conditions"
        },
        {
            "location": "/com/putPrimitive/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/com/putPrimitive/#1_references",
            "text": "",
            "title": "(1) References"
        },
        {
            "location": "/com/putPrimitive/#2_stdstring",
            "text": "",
            "title": "(2) std::string"
        },
        {
            "location": "/com/putPrimitive/#3_reference",
            "text": "",
            "title": "(3) Reference"
        },
        {
            "location": "/com/putPtrs/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *srcBegin, size_t count, \n                      tPrimitive *resultBegin, size_t offset )      // (1) Begin-Offset-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *srcBegin, tPrimitive *srcEnd, \n                  tPrimitive *resultBegin, tPrimitive *resultDst )  // (2) Begin-End-Cursor\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *begin,\n                      tPrimitive *cursor, tPrimitive *end ) // (3) Same Begin-End-Cursor\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *begin, \n                      tPrimitive *end )                     // (4) Same Begin-End\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *begin,\n                      size_t offset, size_t count )         // (5) Same Begin-Offset-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *begin,\n                      size_t count )                        // (6) Same Begin-Count\n\n\n\n\nPuts a buffer of size \ncount\n primitives from source pointer \nsrcBegin\n that is \nlocated in the current processor, and stores it at offset \noffset\n from the \nlocation of \ndstBegin\n in the processor with ID \npid\n.\n\n\n\n\nPuts a buffer of size \ncount\n primitives from source pointer \nsrcBegin\n that \n   is located in the current processor, \n   and stores it at offset \noffset\n from the location of \ndstBegin\n in the \n   processor with ID \npid\n.\n\n\nUses \nsrcBegin\n and \nsrcEnd\n pointers to calculate the number of primitives \n   \ncount\n, and uses \nresultDst\n instead of \noffset\n\n   to determine the offset it needs to start reading from.\n\n\nThe same as (1), but now, it uses \nbegin\n as \nresultBegin\n, \ncursor\n \n   as both \nsrcBegin\n and \nresultDst\n, and \nend\n as \nsrcEnd\n.\n   It stores the values in the same location as they were located in the \n   other processor.\n\n\nThe same as (3), but now \nbegin\n is used as both \nbegin\n and \ncursor\n. \n   It copies the entire range from \nbegin\n to \nend\n from the\n   processor with ID \npid\n to the same location in the current processor.\n\n\nThe same as (3), with the behaviour: \ncursor = begin + offset\n and \n   \nend = begin + offset + count\n.\n\n\nThe same as (5), with the behaviour: \noffset = 0\n.\n\n\n\n\n\n\nTip\n\n\nThere are also other specialisations available. See\n\nContainers\n, \nPrimitives\n\nand \nPointers\n.\n\n\n\n\n\n\nWarnings\n\n\n\n\nstd::string\n is not assumed to be a primitive in this case, although it was in \nBSPLib::Put()\n.\n\n\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to communicate with.\n\n\nsrcBegin\n Pointer to the begin of the information in the other processor.\n\n\noffset\n Offset from the source \nsrcBegin\n in number of primitives to start \n  reading from.\n\n\nresultBegin\n Pointer to the destination for the information in the current processor.\n\n\ncount\n Number of primitives to read.\n\n\nresultDst\n Other method to determine \noffset\n. The behaviour is the same \n  as taking \noffset = resultDst - resultBegin\n.\n\n\nsrcEnd\n Other method to determine \ncount\n. The behaviour is the same \n  as taking \ncount = srcEnd - srcBegin\n.\n\n\nbegin\n Pointer to the begin of the information in both the processors.\n\n\ncursor\n Cursor to start reading from in the current processor, and \n  to start writing to in the other processor.\n\n\nend\n End of the information block to put.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nNone of the pointers \nsrcBegin\n, \nresultBegin\n, \nresultDst\n, \nsrcEnd\n,\n  \nbegin\n, \ncursor\n and \nend\n is allowed to be \nnullptr\n. \n\n\nBSPLib::Push()\n has been called on \nresultBegin\n\n  or \nbegin\n with at least size \noffset + nbytes\n in the processor with ID \npid\n.\n\n\nA \nBSPLib::Sync()\n has happened between \n  \nBSPLig::Push()\n and this call.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nPut request has been queued.\n\n\nIn the next superstep \nBSPLib::Sync()\n, the \n  destination in the current processor will have the copied value \n  from the source in the other processor.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Begin-Offset-Count\n\u00b6\n\n\n(2) Begin-End-Cursor\n\u00b6\n\n\n(3) Same Begin-End-Cursor\n\u00b6\n\n\n(4) Same Begin-End\n\u00b6\n\n\n(5) Same Begin-Offset-Count\n\u00b6\n\n\n(6) Same Begin-Count\n\u00b6",
            "title": "Pointers"
        },
        {
            "location": "/com/putPtrs/#interfaces",
            "text": "template< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *srcBegin, size_t count, \n                      tPrimitive *resultBegin, size_t offset )      // (1) Begin-Offset-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *srcBegin, tPrimitive *srcEnd, \n                  tPrimitive *resultBegin, tPrimitive *resultDst )  // (2) Begin-End-Cursor\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *begin,\n                      tPrimitive *cursor, tPrimitive *end ) // (3) Same Begin-End-Cursor\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *begin, \n                      tPrimitive *end )                     // (4) Same Begin-End\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *begin,\n                      size_t offset, size_t count )         // (5) Same Begin-Offset-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::PutPtrs( uint32_t pid, tPrimitive *begin,\n                      size_t count )                        // (6) Same Begin-Count  Puts a buffer of size  count  primitives from source pointer  srcBegin  that is \nlocated in the current processor, and stores it at offset  offset  from the \nlocation of  dstBegin  in the processor with ID  pid .   Puts a buffer of size  count  primitives from source pointer  srcBegin  that \n   is located in the current processor, \n   and stores it at offset  offset  from the location of  dstBegin  in the \n   processor with ID  pid .  Uses  srcBegin  and  srcEnd  pointers to calculate the number of primitives \n    count , and uses  resultDst  instead of  offset \n   to determine the offset it needs to start reading from.  The same as (1), but now, it uses  begin  as  resultBegin ,  cursor  \n   as both  srcBegin  and  resultDst , and  end  as  srcEnd .\n   It stores the values in the same location as they were located in the \n   other processor.  The same as (3), but now  begin  is used as both  begin  and  cursor . \n   It copies the entire range from  begin  to  end  from the\n   processor with ID  pid  to the same location in the current processor.  The same as (3), with the behaviour:  cursor = begin + offset  and \n    end = begin + offset + count .  The same as (5), with the behaviour:  offset = 0 .    Tip  There are also other specialisations available. See Containers ,  Primitives \nand  Pointers .    Warnings   std::string  is not assumed to be a primitive in this case, although it was in  BSPLib::Put() .",
            "title": "Interfaces"
        },
        {
            "location": "/com/putPtrs/#parameters",
            "text": "pid  The ID of the processor to communicate with.  srcBegin  Pointer to the begin of the information in the other processor.  offset  Offset from the source  srcBegin  in number of primitives to start \n  reading from.  resultBegin  Pointer to the destination for the information in the current processor.  count  Number of primitives to read.  resultDst  Other method to determine  offset . The behaviour is the same \n  as taking  offset = resultDst - resultBegin .  srcEnd  Other method to determine  count . The behaviour is the same \n  as taking  count = srcEnd - srcBegin .  begin  Pointer to the begin of the information in both the processors.  cursor  Cursor to start reading from in the current processor, and \n  to start writing to in the other processor.  end  End of the information block to put.",
            "title": "Parameters"
        },
        {
            "location": "/com/putPtrs/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  None of the pointers  srcBegin ,  resultBegin ,  resultDst ,  srcEnd ,\n   begin ,  cursor  and  end  is allowed to be  nullptr .   BSPLib::Push()  has been called on  resultBegin \n  or  begin  with at least size  offset + nbytes  in the processor with ID  pid .  A  BSPLib::Sync()  has happened between \n   BSPLig::Push()  and this call.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/com/putPtrs/#post-conditions",
            "text": "Put request has been queued.  In the next superstep  BSPLib::Sync() , the \n  destination in the current processor will have the copied value \n  from the source in the other processor.",
            "title": "Post-Conditions"
        },
        {
            "location": "/com/putPtrs/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/com/putPtrs/#1_begin-offset-count",
            "text": "",
            "title": "(1) Begin-Offset-Count"
        },
        {
            "location": "/com/putPtrs/#2_begin-end-cursor",
            "text": "",
            "title": "(2) Begin-End-Cursor"
        },
        {
            "location": "/com/putPtrs/#3_same_begin-end-cursor",
            "text": "",
            "title": "(3) Same Begin-End-Cursor"
        },
        {
            "location": "/com/putPtrs/#4_same_begin-end",
            "text": "",
            "title": "(4) Same Begin-End"
        },
        {
            "location": "/com/putPtrs/#5_same_begin-offset-count",
            "text": "",
            "title": "(5) Same Begin-Offset-Count"
        },
        {
            "location": "/com/putPtrs/#6_same_begin-count",
            "text": "",
            "title": "(6) Same Begin-Count"
        },
        {
            "location": "/com/putContainer/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tIterator, typename tOutputIterator >\n    void BSPLib::PutIterator( uint32_t pid, tIterator srcBegin, size_t count, \n                      tOutputIterator resultBegin, \n                      size_t offset )                           // (1) Begin-Offset-Count\n\ntemplate< typename tIterator, typename tOutputIterator >\nvoid BSPLib::PutIterator( uint32_t pid, tIterator srcBegin, tIterator srcEnd, \n                          tOutputIterator resultBegin,\n                          tOutputIterator resultDst )           // (2) Begin-Cursor-End\n\ntemplate< typename tIterator >\nvoid BSPLib::PutIterator( uint32_t pid, tIterator begin, \n                          tIterator cursor, tIterator end )     // (3) Same Begin-Cursor-End\n\ntemplate< typename tIterator >\nvoid BSPLib::PutIterator( uint32_t pid, tIterator begin, \n                          tIterator end )                       // (4) Same Begin-End\n\ntemplate< typename tIterator >\nvoid BSPLib::PutIterator( uint32_t pid, tIterator begin,\n                          size_t offset, size_t count )         // (5) Same Begin-Offset-Count\n\ntemplate< typename tPrimitive, size_t tSizeIn, size_t tSizeOut >\nvoid BSPLib::PutCArray( uint32_t pid, tPrimitive( &srcCArray )[tSizeIn], \n                        tPrimitive( &dstCArray )[tSizeOut] )    // (6) C-Array\n\ntemplate< typename tPrimitive, size_t tSizeIn, size_t tSizeOut >\nvoid BSPLib::PutCArray( uint32_t pid, \n                        tPrimitive( &cArray )[tSizeIn] )        // (7) Same C-Array\n\ntemplate < typename tContainerIn, typename tContainerOut >\nvoid BSPLib::PutContainer( uint32_t pid, tContainerIn &srcContainer,\n                           tContainerOut &dstContainer )        // (8) General container \n\ntemplate < typename tContainerIn, typename tContainerOut >\nvoid BSPLib::PutContainer( uint32_t pid\n                           tContainer &container )              // (9) Same container\n\n\n\n\nPushes a register, with the given size. \n\n\n\n\nPuts a buffer of size \ncount\n primitives from source iterator \n   \nsrcBegin\n that is located in the current processor\n   and stores it at the location of \ndstBegin\n in the processor with identifier \n   \npid\n, at offset \noffset\n from \ndstBegin\n.\n\n\nHas the same behaviour as (1), using that \noffset = resultDst - resultBegin\n \n   and \ncount = srcEnd - srcBegin\n.\n\n\nHas the same behaviour as (1), using that \nresultBegin = begin\n, \n   \nsrcBegin = resultDst = cursor\n and \nsrcEnd = end\n.\n\n\nHas the same behaviour as (3), using that \ncursor = begin\n.\n\n\nHas the same behaviour as (1), using that \nsrcBegin = resultBegin = begin\n.\n\n\nPuts an entire C-Array as buffer from \nsrcCArray\n and stores it at the \n   location of \ndstCArray\nin the processor with identifier \npid\n.\n\n\nHas the same behaviour as (6), but now \nsrcCArray = dstCArray = cArray\n, \n   so the source is in the same location as the destination, but in the other processor.\n\n\nPuts an entire container as buffer from \nsrcContainer\n and stores it \n   at the location of \ndstContainer\n located in the processor with identifier \npid\n .\n\n\nHas the same behaviour as (8), but now \nsrcContainer = dstContainer = container\n.\n\n\n\n\n\n\nTip\n\n\nThere are also other specialisations available. See\n\nContainers\n, \nPrimitives\n\nand \nPointers\n.\n\n\n\n\n\n\nWarnings\n\n\n\n\nIn case of (8) and (9), make sure the container is described by \n   contiguous iterators.\n\n\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The identifier of the processor to communicate with.\n\n\nsrcBegin\n Iterator describing the begin of the information in the \n  current processor.\n\n\noffset\n Offset from the source \nsrcBegin\n in number of primitives to \n  start reading from.\n\n\nresultBegin\n Iterator describing the destination for the information in \n  the other processor.\n\n\ncount\n Number of primitives to read.\n\n\nsrcEnd\n Other method to determine \ncount\n. The behaviour is the same as\n  taking \ncount = srcEnd - srcBegin\n.\n\n\nresultDst\n Other method to determine \noffset\n. The behaviour is the same \n  as taking \noffset = resultDst - resultBegin\n.\n\n\nbegin\n Iterator describing the begin of the information in both the processors.\n\n\ncursor\n Cursor to start reading from in the current processor, and to \n  start writing to in the other processor.\n\n\nend\n End of the information block to put.\n\n\nsrcCArray\n C-Array located in the current processor, the source of the \n  information.\n\n\ndstCArray\n C-Array located in the other processor, the destination for\n  the information.\n\n\ncArray\n C-Array that is located in both the processors, both the source\n  and the destination for the information.\n\n\nsrcContainer\n Container located in the current processor, the source\n  of the information.\n\n\ndstContainer\n Container located in the other processor, the destination\n  for the information.\n\n\ncontainer\n Container that is located in both the processors, both the\n  source and the destination for the information.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nBSPLib::Push()\n has been called on the destination, \n  in the processor with identifier \npid\n, with at least the same size as the source.\n\n\nA \nBSPLib::Sync()\n has happened between \n  \nBSPLig::Push()\n and this call.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nPut request has been queued.\n\n\nIn the next superstep \nBSPLib::Sync()\n, destination in the \n  current processor will have the copied value from the source in the other processor.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Begin-Offset-Count\n\u00b6\n\n\n(2) Begin-Cursor-End\n\u00b6\n\n\n(3) Same Begin-Cursor-End\n\u00b6\n\n\n(4) Same Begin-End\n\u00b6\n\n\n(5) Same Begin-Offset-Count\n\u00b6\n\n\n(6) C-Array\n\u00b6\n\n\n(7) Same C-Array\n\u00b6\n\n\n(8) General container\n\u00b6\n\n\n(9) Same container\n\u00b6",
            "title": "Containers"
        },
        {
            "location": "/com/putContainer/#interfaces",
            "text": "template< typename tIterator, typename tOutputIterator >\n    void BSPLib::PutIterator( uint32_t pid, tIterator srcBegin, size_t count, \n                      tOutputIterator resultBegin, \n                      size_t offset )                           // (1) Begin-Offset-Count\n\ntemplate< typename tIterator, typename tOutputIterator >\nvoid BSPLib::PutIterator( uint32_t pid, tIterator srcBegin, tIterator srcEnd, \n                          tOutputIterator resultBegin,\n                          tOutputIterator resultDst )           // (2) Begin-Cursor-End\n\ntemplate< typename tIterator >\nvoid BSPLib::PutIterator( uint32_t pid, tIterator begin, \n                          tIterator cursor, tIterator end )     // (3) Same Begin-Cursor-End\n\ntemplate< typename tIterator >\nvoid BSPLib::PutIterator( uint32_t pid, tIterator begin, \n                          tIterator end )                       // (4) Same Begin-End\n\ntemplate< typename tIterator >\nvoid BSPLib::PutIterator( uint32_t pid, tIterator begin,\n                          size_t offset, size_t count )         // (5) Same Begin-Offset-Count\n\ntemplate< typename tPrimitive, size_t tSizeIn, size_t tSizeOut >\nvoid BSPLib::PutCArray( uint32_t pid, tPrimitive( &srcCArray )[tSizeIn], \n                        tPrimitive( &dstCArray )[tSizeOut] )    // (6) C-Array\n\ntemplate< typename tPrimitive, size_t tSizeIn, size_t tSizeOut >\nvoid BSPLib::PutCArray( uint32_t pid, \n                        tPrimitive( &cArray )[tSizeIn] )        // (7) Same C-Array\n\ntemplate < typename tContainerIn, typename tContainerOut >\nvoid BSPLib::PutContainer( uint32_t pid, tContainerIn &srcContainer,\n                           tContainerOut &dstContainer )        // (8) General container \n\ntemplate < typename tContainerIn, typename tContainerOut >\nvoid BSPLib::PutContainer( uint32_t pid\n                           tContainer &container )              // (9) Same container  Pushes a register, with the given size.    Puts a buffer of size  count  primitives from source iterator \n    srcBegin  that is located in the current processor\n   and stores it at the location of  dstBegin  in the processor with identifier \n    pid , at offset  offset  from  dstBegin .  Has the same behaviour as (1), using that  offset = resultDst - resultBegin  \n   and  count = srcEnd - srcBegin .  Has the same behaviour as (1), using that  resultBegin = begin , \n    srcBegin = resultDst = cursor  and  srcEnd = end .  Has the same behaviour as (3), using that  cursor = begin .  Has the same behaviour as (1), using that  srcBegin = resultBegin = begin .  Puts an entire C-Array as buffer from  srcCArray  and stores it at the \n   location of  dstCArray in the processor with identifier  pid .  Has the same behaviour as (6), but now  srcCArray = dstCArray = cArray , \n   so the source is in the same location as the destination, but in the other processor.  Puts an entire container as buffer from  srcContainer  and stores it \n   at the location of  dstContainer  located in the processor with identifier  pid  .  Has the same behaviour as (8), but now  srcContainer = dstContainer = container .    Tip  There are also other specialisations available. See Containers ,  Primitives \nand  Pointers .    Warnings   In case of (8) and (9), make sure the container is described by \n   contiguous iterators.",
            "title": "Interfaces"
        },
        {
            "location": "/com/putContainer/#parameters",
            "text": "pid  The identifier of the processor to communicate with.  srcBegin  Iterator describing the begin of the information in the \n  current processor.  offset  Offset from the source  srcBegin  in number of primitives to \n  start reading from.  resultBegin  Iterator describing the destination for the information in \n  the other processor.  count  Number of primitives to read.  srcEnd  Other method to determine  count . The behaviour is the same as\n  taking  count = srcEnd - srcBegin .  resultDst  Other method to determine  offset . The behaviour is the same \n  as taking  offset = resultDst - resultBegin .  begin  Iterator describing the begin of the information in both the processors.  cursor  Cursor to start reading from in the current processor, and to \n  start writing to in the other processor.  end  End of the information block to put.  srcCArray  C-Array located in the current processor, the source of the \n  information.  dstCArray  C-Array located in the other processor, the destination for\n  the information.  cArray  C-Array that is located in both the processors, both the source\n  and the destination for the information.  srcContainer  Container located in the current processor, the source\n  of the information.  dstContainer  Container located in the other processor, the destination\n  for the information.  container  Container that is located in both the processors, both the\n  source and the destination for the information.",
            "title": "Parameters"
        },
        {
            "location": "/com/putContainer/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  BSPLib::Push()  has been called on the destination, \n  in the processor with identifier  pid , with at least the same size as the source.  A  BSPLib::Sync()  has happened between \n   BSPLig::Push()  and this call.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/com/putContainer/#post-conditions",
            "text": "Put request has been queued.  In the next superstep  BSPLib::Sync() , destination in the \n  current processor will have the copied value from the source in the other processor.",
            "title": "Post-Conditions"
        },
        {
            "location": "/com/putContainer/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/com/putContainer/#1_begin-offset-count",
            "text": "",
            "title": "(1) Begin-Offset-Count"
        },
        {
            "location": "/com/putContainer/#2_begin-cursor-end",
            "text": "",
            "title": "(2) Begin-Cursor-End"
        },
        {
            "location": "/com/putContainer/#3_same_begin-cursor-end",
            "text": "",
            "title": "(3) Same Begin-Cursor-End"
        },
        {
            "location": "/com/putContainer/#4_same_begin-end",
            "text": "",
            "title": "(4) Same Begin-End"
        },
        {
            "location": "/com/putContainer/#5_same_begin-offset-count",
            "text": "",
            "title": "(5) Same Begin-Offset-Count"
        },
        {
            "location": "/com/putContainer/#6_c-array",
            "text": "",
            "title": "(6) C-Array"
        },
        {
            "location": "/com/putContainer/#7_same_c-array",
            "text": "",
            "title": "(7) Same C-Array"
        },
        {
            "location": "/com/putContainer/#8_general_container",
            "text": "",
            "title": "(8) General container"
        },
        {
            "location": "/com/putContainer/#9_same_container",
            "text": "",
            "title": "(9) Same container"
        },
        {
            "location": "/sync/sync/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Sync()              // (1) Modern\nvoid BSPLib::Classic::Sync()     // (2) Classic\nvoid bsp_sync()                  // (3) BSP\n\n\n\n\nSynchronises all threads and communications. This marks the end of a computation super step, \nand each processor can handle its own computations between the super steps. At the end (and not earlier)\nof the super step in the synchronisation point, the communication is handled. All threads have queued\ntheir desired communications before this point, and the queues will now be handled here. The \nsynchronisation point also ensures all threads are synchronised, and functions as a barrier.\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Classic::Begin()\n has been called.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\nAll threads have completed this superstep.\n\n\nTagsize has been synchronized and is available in the next superstep.\n\n\nGet requests have been processed, updated data is available in the next superstep.\n\n\nPop requests have been processed, registers will be unavailable in the next superstep.\n\n\nPut requests have been processed, updated data is available in the next superstep.\n\n\nBuffers for the put requests have been cleared.\n\n\nPush requests have been processed, registers will be available in the next superstep.\n\n\n\n\n\n\nThis is interface one should choose to use, and is semantically the same as the other interfaces.\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Modern\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    const uint32_t nProcs = BSPLib::NProcs();\n    // Waits for all threads to print the first line, \n    // before printing the second line.\n      BSPLib::Execute( []\n    {            \n        std::cout << \"Thread \" <<  BSPLib::ProcId() \n                  << \" waiting on barrier 1\" << std::endl;\n\n        // Wait for all threads to print\n        BSPLib::Sync();\n\n        std::cout << \"Thread \" <<  BSPLib::ProcId() \n                  << \" waiting on barrier 2\" << std::endl;\n\n        BSPLib::Sync();\n    }, nProcs );\n}\n\n\n\n\n(2) Classic\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    const uint32_t nProcs = BSPLib::NProcs();\n    // Waits for all threads to print the first line, \n    // before printing the second line.\n      BSPLib::Execute( []\n    {            \n        std::cout << \"Thread \" <<  BSPLib::Classic::ProcId() \n                  << \" waiting on barrier 1\" << std::endl;\n\n        // Wait for all threads to print\n        BSPLib::Classic::Sync();\n\n        std::cout << \"Thread \" <<  BSPLib::Classic::ProcId() \n                  << \" waiting on barrier 2\" << std::endl;\n\n        BSPLib::Classic::Sync();\n    }, nProcs );\n}\n\n\n\n\n(3) BSP\n\u00b6\n\n\nvoid main( int32_t, const char ** )\n{\n    const uint32_t nProcs = bsp_nprocs();\n    // Waits for all threads to print the first line, \n    // before printing the second line.\n      BSPLib::Execute( []\n    {            \n        std::cout << \"Thread \" <<  bsp_pid() \n                  << \" waiting on barrier 1\" << std::endl;\n\n        // Wait for all threads to print\n        bsp_sync();\n\n        std::cout << \"Thread \" <<  bsp_pid() \n                  << \" waiting on barrier 2\" << std::endl;\n        bsp_sync();\n    }, nProcs );\n}",
            "title": "Synchronising"
        },
        {
            "location": "/sync/sync/#interfaces",
            "text": "void BSPLib::Sync()              // (1) Modern\nvoid BSPLib::Classic::Sync()     // (2) Classic\nvoid bsp_sync()                  // (3) BSP  Synchronises all threads and communications. This marks the end of a computation super step, \nand each processor can handle its own computations between the super steps. At the end (and not earlier)\nof the super step in the synchronisation point, the communication is handled. All threads have queued\ntheir desired communications before this point, and the queues will now be handled here. The \nsynchronisation point also ensures all threads are synchronised, and functions as a barrier.",
            "title": "Interfaces"
        },
        {
            "location": "/sync/sync/#pre-conditions",
            "text": "BSPLib::Classic::Begin()  has been called.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/sync/sync/#post-conditions",
            "text": "All threads have completed this superstep.  Tagsize has been synchronized and is available in the next superstep.  Get requests have been processed, updated data is available in the next superstep.  Pop requests have been processed, registers will be unavailable in the next superstep.  Put requests have been processed, updated data is available in the next superstep.  Buffers for the put requests have been cleared.  Push requests have been processed, registers will be available in the next superstep.    This is interface one should choose to use, and is semantically the same as the other interfaces.  Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.",
            "title": "Post-Conditions"
        },
        {
            "location": "/sync/sync/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/sync/sync/#1_modern",
            "text": "void main( int32_t, const char ** )\n{\n    const uint32_t nProcs = BSPLib::NProcs();\n    // Waits for all threads to print the first line, \n    // before printing the second line.\n      BSPLib::Execute( []\n    {            \n        std::cout << \"Thread \" <<  BSPLib::ProcId() \n                  << \" waiting on barrier 1\" << std::endl;\n\n        // Wait for all threads to print\n        BSPLib::Sync();\n\n        std::cout << \"Thread \" <<  BSPLib::ProcId() \n                  << \" waiting on barrier 2\" << std::endl;\n\n        BSPLib::Sync();\n    }, nProcs );\n}",
            "title": "(1) Modern"
        },
        {
            "location": "/sync/sync/#2_classic",
            "text": "void main( int32_t, const char ** )\n{\n    const uint32_t nProcs = BSPLib::NProcs();\n    // Waits for all threads to print the first line, \n    // before printing the second line.\n      BSPLib::Execute( []\n    {            \n        std::cout << \"Thread \" <<  BSPLib::Classic::ProcId() \n                  << \" waiting on barrier 1\" << std::endl;\n\n        // Wait for all threads to print\n        BSPLib::Classic::Sync();\n\n        std::cout << \"Thread \" <<  BSPLib::Classic::ProcId() \n                  << \" waiting on barrier 2\" << std::endl;\n\n        BSPLib::Classic::Sync();\n    }, nProcs );\n}",
            "title": "(2) Classic"
        },
        {
            "location": "/sync/sync/#3_bsp",
            "text": "void main( int32_t, const char ** )\n{\n    const uint32_t nProcs = bsp_nprocs();\n    // Waits for all threads to print the first line, \n    // before printing the second line.\n      BSPLib::Execute( []\n    {            \n        std::cout << \"Thread \" <<  bsp_pid() \n                  << \" waiting on barrier 1\" << std::endl;\n\n        // Wait for all threads to print\n        bsp_sync();\n\n        std::cout << \"Thread \" <<  bsp_pid() \n                  << \" waiting on barrier 2\" << std::endl;\n        bsp_sync();\n    }, nProcs );\n}",
            "title": "(3) BSP"
        },
        {
            "location": "/messaging/send/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::Send( uint32_t pid, const void *tag,\n                            const void *payload, size_t size ) // (1) Classic\nvoid bsp_send( uint32_t pid, const void *tag,\n               const void *payload, size_t size )              // (2) Legacy\n\n\n\n\nSend a buffered message to the processor with ID pid using a tag to identify the message.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\n\n\n\n\nTip\n\n\nThere are easier functions to work with. See for \nContainers\n,\n\nPrimitives\n, \nIterators\n, \nPointers with Primitive Tags\n\nand \nPointers with Container Tags\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to send to.\n\n\ntag\n The tag by which the other processor can identify the message.\n\n\npayload\n Pointer to the payload of the message.\n\n\nsize\n Size of the message in bytes.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nTagsize is equal on all threads.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\n(2) Legacy\n\u00b6",
            "title": "Normal"
        },
        {
            "location": "/messaging/send/#interfaces",
            "text": "void BSPLib::Classic::Send( uint32_t pid, const void *tag,\n                            const void *payload, size_t size ) // (1) Classic\nvoid bsp_send( uint32_t pid, const void *tag,\n               const void *payload, size_t size )              // (2) Legacy  Send a buffered message to the processor with ID pid using a tag to identify the message.   Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.    Tip  There are easier functions to work with. See for  Containers , Primitives ,  Iterators ,  Pointers with Primitive Tags \nand  Pointers with Container Tags .",
            "title": "Interfaces"
        },
        {
            "location": "/messaging/send/#parameters",
            "text": "pid  The ID of the processor to send to.  tag  The tag by which the other processor can identify the message.  payload  Pointer to the payload of the message.  size  Size of the message in bytes.",
            "title": "Parameters"
        },
        {
            "location": "/messaging/send/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  Tagsize is equal on all threads.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messaging/send/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messaging/send/#1_classic",
            "text": "",
            "title": "(1) Classic"
        },
        {
            "location": "/messaging/send/#2_legacy",
            "text": "",
            "title": "(2) Legacy"
        },
        {
            "location": "/messaging/sendPrimitive/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tPrimitive, typename tTag >\nvoid BSPLib::Send( uint32_t pid, tTag &tag,\n                   const tPrimitive &payload )                      // (1) References\n\ntemplate< typename tTag >\nvoid BSPLib::Send( uint32_t pid, tTag &tag, \n                   const std::string &payload )                     // (2) std::string-Reference\n\ntemplate< typename tPrimitive, typename tTag >\nvoid BSPLib::Send( uint32_t pid, tTag *tagPtr, \n                   const tPrimitive &payload )                      // (3) Reference-Pointer\n\ntemplate< typename tTag >\nvoid BSPLib::Send( uint32_t pid, tTag *tagPtr,\n                   const std::string &payload )                     // (4) std::string-Pointer\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Send( uint32_t pid, const tPrimitive &payload )        // (5) Reference\n\ntemplate<>\nvoid BSPLib::Send( uint32_t pid, const std::string &payload )       // (6) std::string\n\ntemplate< typename tPrimitive, typename tTagPrimitive, size_t tTagSize >\nvoid BSPLib::SendWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize],\n                     const tPrimitive &payload )                    // (7) Reference-CArray\n\ntemplate< typename tTagPrimitive, size_t tTagSize >\nvoid BSPLib::SendWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize],\n                     const std::string &payload )                   // (8) std::string-CArray\n\n\n\n\nSend a buffered message to the processor with ID pid using a tag to identify the message.\n\n\n\n\nSends one primitive as message, accompanied by a tag that may either be a primitive or a contiguous container.\n\n\nOverload of (1) for \nstd::string\n.\n\n\nSends one primitive as message, accompanied by a tag that starts at \ntagPtr\n.\n\n\nOverload of (3) for \nstd::string\n.\n\n\nSends one primitive as message, without a tag.\n\n\nOverload of (5) for \nstd::string\n.\n\n\nSends one primitive as message, accompanied by a tag that is a C-Array.\n\n\nOverload of (7) for \nstd::string\n.\n\n\n\n\n\n\nTip\n\n\n\n\nThere are also other specialisations available. See\n  \nContainers\n, \nPrimitives\n, \nIterators\n,\n  \nPointes with Primitive Tags\n and \nPointers with Container Tags\n.\n\n\nYou can safely pass both primitives and contiguous containers, like \nstd::vector\n\n  or \nstd:array\n using the \ntag\n parameter. They will be specialised by \n  \nBSPLib::SendPtrs()\n that is called internally.\n\n\nIf you want to use a reference to a primitive as a tag, have a look at\n  \nSend Memory - Pointers - Primitives\n.\n\n\nIf you want to use a reference to a container as a tag, have a look at\n  \nSend Memory - Pointers - Containers\n.\n\n\n\n\n\n\n\n\nWarnings\n\n\nMake sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See \nBSPLib::SetTagSize()\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to send to.\n\n\ntag\n The tag by which the other processor can identify the message. This may be either a primitive or a contiguous container.\n\n\npayload\n Reference to the primitive that will be the payload of the message.\n\n\ntagPtr\n Pointer to the beginning of the tag.\n\n\ntagContainer\n C-Array containing the tag.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nTagsize is equal on all threads.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) References\n\u00b6\n\n\n(2) std::string-Reference\n\u00b6\n\n\n(3) Reference-Pointer\n\u00b6\n\n\n(4) std::string-Pointer\n\u00b6\n\n\n(5) Reference\n\u00b6\n\n\n(6) std::string\n\u00b6\n\n\n(7) Reference-CArray\n\u00b6\n\n\n(8) std::string-CArray\n\u00b6",
            "title": "Primitives"
        },
        {
            "location": "/messaging/sendPrimitive/#interfaces",
            "text": "template< typename tPrimitive, typename tTag >\nvoid BSPLib::Send( uint32_t pid, tTag &tag,\n                   const tPrimitive &payload )                      // (1) References\n\ntemplate< typename tTag >\nvoid BSPLib::Send( uint32_t pid, tTag &tag, \n                   const std::string &payload )                     // (2) std::string-Reference\n\ntemplate< typename tPrimitive, typename tTag >\nvoid BSPLib::Send( uint32_t pid, tTag *tagPtr, \n                   const tPrimitive &payload )                      // (3) Reference-Pointer\n\ntemplate< typename tTag >\nvoid BSPLib::Send( uint32_t pid, tTag *tagPtr,\n                   const std::string &payload )                     // (4) std::string-Pointer\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Send( uint32_t pid, const tPrimitive &payload )        // (5) Reference\n\ntemplate<>\nvoid BSPLib::Send( uint32_t pid, const std::string &payload )       // (6) std::string\n\ntemplate< typename tPrimitive, typename tTagPrimitive, size_t tTagSize >\nvoid BSPLib::SendWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize],\n                     const tPrimitive &payload )                    // (7) Reference-CArray\n\ntemplate< typename tTagPrimitive, size_t tTagSize >\nvoid BSPLib::SendWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize],\n                     const std::string &payload )                   // (8) std::string-CArray  Send a buffered message to the processor with ID pid using a tag to identify the message.   Sends one primitive as message, accompanied by a tag that may either be a primitive or a contiguous container.  Overload of (1) for  std::string .  Sends one primitive as message, accompanied by a tag that starts at  tagPtr .  Overload of (3) for  std::string .  Sends one primitive as message, without a tag.  Overload of (5) for  std::string .  Sends one primitive as message, accompanied by a tag that is a C-Array.  Overload of (7) for  std::string .    Tip   There are also other specialisations available. See\n   Containers ,  Primitives ,  Iterators ,\n   Pointes with Primitive Tags  and  Pointers with Container Tags .  You can safely pass both primitives and contiguous containers, like  std::vector \n  or  std:array  using the  tag  parameter. They will be specialised by \n   BSPLib::SendPtrs()  that is called internally.  If you want to use a reference to a primitive as a tag, have a look at\n   Send Memory - Pointers - Primitives .  If you want to use a reference to a container as a tag, have a look at\n   Send Memory - Pointers - Containers .     Warnings  Make sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See  BSPLib::SetTagSize() .",
            "title": "Interfaces"
        },
        {
            "location": "/messaging/sendPrimitive/#parameters",
            "text": "pid  The ID of the processor to send to.  tag  The tag by which the other processor can identify the message. This may be either a primitive or a contiguous container.  payload  Reference to the primitive that will be the payload of the message.  tagPtr  Pointer to the beginning of the tag.  tagContainer  C-Array containing the tag.",
            "title": "Parameters"
        },
        {
            "location": "/messaging/sendPrimitive/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  Tagsize is equal on all threads.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messaging/sendPrimitive/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messaging/sendPrimitive/#1_references",
            "text": "",
            "title": "(1) References"
        },
        {
            "location": "/messaging/sendPrimitive/#2_stdstring-reference",
            "text": "",
            "title": "(2) std::string-Reference"
        },
        {
            "location": "/messaging/sendPrimitive/#3_reference-pointer",
            "text": "",
            "title": "(3) Reference-Pointer"
        },
        {
            "location": "/messaging/sendPrimitive/#4_stdstring-pointer",
            "text": "",
            "title": "(4) std::string-Pointer"
        },
        {
            "location": "/messaging/sendPrimitive/#5_reference",
            "text": "",
            "title": "(5) Reference"
        },
        {
            "location": "/messaging/sendPrimitive/#6_stdstring",
            "text": "",
            "title": "(6) std::string"
        },
        {
            "location": "/messaging/sendPrimitive/#7_reference-carray",
            "text": "",
            "title": "(7) Reference-CArray"
        },
        {
            "location": "/messaging/sendPrimitive/#8_stdstring-carray",
            "text": "",
            "title": "(8) std::string-CArray"
        },
        {
            "location": "/messaging/sendIterator/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tIterator, typename tTag >\nvoid BSPLib::SendIterator( uint32_t pid, tTag &tag, tIterator begin, \n                           size_t count )                               // (1) Begin-Count-Reference\n\ntemplate< typename tIterator, typename tTag >\nvoid BSPLib::SendIterator( uint32_t pid, tTag *tagPtr, tIterator begin, \n                           size_t count )                               // (2) Begin-Count-Pointer\n\ntemplate< typename tIterator, typename tTag >\nvoid BSPLib::SendIterator( uint32_t pid, tTag &tag, tIterator begin,\n                           tIterator end )                              // (3) Begin-End-Reference\n\ntemplate< typename tIterator, typename tTag >\nvoid BSPLib::SendIterator( uint32_t pid, tTag *tagPtr, tIterator begin, \n                           tIterator end )                              // (4) Begin-End-Pointer\n\ntemplate< typename tIterator, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendIteratorWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize],\n                                     tIterator begin, size_t count )    // (5) Begin-Count-CArray\n\ntemplate< typename tIterator, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendIteratorWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize], \n                                     tIterator begin, tIterator end )   // (6) Begin-End-CArray\n\n\n\ntemplate< typename tIterator >\nvoid BSPLib::SendIterator( uint32_t pid, tIterator begin,\n                           size_t count )                               // (7) Begin-Count\n\ntemplate< typename tIterator >\nvoid BSPLib::SendIterator( uint32_t pid, tIterator begin,\n                           tIterator end )                              // (8) Begin-End\n\n\n\n\nSend a buffered message to the processor with ID pid using a tag to identify the message.\n\n\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that may either be a primitive or a contiguous container.\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that starts at \ntagPtr\n.\n\n\nHas the same behaviour as (1), using that \ncount = end - begin\n.\n\n\nHas the same behaviour as (2), using that \ncount = end - begin\n.\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that is an entire C-Array.\n\n\nHas the same behaviour as (5), using that \ncount = end - begin\n.\n\n\nHas the same behaviour as (2), using that \ntagPtr = nullptr\n, no tag is sent.\n\n\nHas the same behaviour as (4), using that \ntagPtr = nullptr\n, no tag is sent.\n\n\n\n\n\n\nTip\n\n\n\n\nThere are also other specialisations available. See\n  \nContainers\n, \nPrimitives\n, \nIterators\n,\n  \nPointes with Primitive Tags\n and \nPointers with Container Tags\n.\n\n\nYou can safely pass both primitives and contiguous containers, like \nstd::vector\n\n  or \nstd:array\n using the \ntag\n parameter. They will be specialised by \n  \nBSPLib::SendPtrs()\n that is called internally.\n\n\nIf you want to use a reference to a primitive as a tag, have a look at\n  \nSend Memory - Pointers - Primitives\n.\n\n\nIf you want to use a reference to a container as a tag, have a look at\n  \nSend Memory - Pointers - Containers\n.\n\n\n\n\n\n\n\n\nWarnings\n\n\nMake sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See \nBSPLib::SetTagSize()\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to send to.\n\n\ntag\n The tag by which the other processor can identify the message. This may be either a primitive or a contiguous container.\n\n\nbegin\n Iterator describing the begin of the payload.\n\n\nend\n Iterator describing the end of the payload.\n\n\ncount\n Number of primitives in the payload.\n\n\ntagPtr\n Pointer to the beginning of the tag.\n\n\ntagContainer\n C-Array containing the tag.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nTagsize is equal on all threads.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Begin-Count-Reference\n\u00b6\n\n\n(2) Begin-Count-Pointer\n\u00b6\n\n\n(3) Begin-End-Reference\n\u00b6\n\n\n(4) Begin-End-Pointer\n\u00b6\n\n\n(5) Begin-Count-CArray\n\u00b6\n\n\n(6) Begin-End-CArray\n\u00b6\n\n\n(7) Begin-Count\n\u00b6\n\n\n(8) Begin-End\n\u00b6",
            "title": "Iterators"
        },
        {
            "location": "/messaging/sendIterator/#interfaces",
            "text": "template< typename tIterator, typename tTag >\nvoid BSPLib::SendIterator( uint32_t pid, tTag &tag, tIterator begin, \n                           size_t count )                               // (1) Begin-Count-Reference\n\ntemplate< typename tIterator, typename tTag >\nvoid BSPLib::SendIterator( uint32_t pid, tTag *tagPtr, tIterator begin, \n                           size_t count )                               // (2) Begin-Count-Pointer\n\ntemplate< typename tIterator, typename tTag >\nvoid BSPLib::SendIterator( uint32_t pid, tTag &tag, tIterator begin,\n                           tIterator end )                              // (3) Begin-End-Reference\n\ntemplate< typename tIterator, typename tTag >\nvoid BSPLib::SendIterator( uint32_t pid, tTag *tagPtr, tIterator begin, \n                           tIterator end )                              // (4) Begin-End-Pointer\n\ntemplate< typename tIterator, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendIteratorWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize],\n                                     tIterator begin, size_t count )    // (5) Begin-Count-CArray\n\ntemplate< typename tIterator, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendIteratorWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize], \n                                     tIterator begin, tIterator end )   // (6) Begin-End-CArray\n\n\n\ntemplate< typename tIterator >\nvoid BSPLib::SendIterator( uint32_t pid, tIterator begin,\n                           size_t count )                               // (7) Begin-Count\n\ntemplate< typename tIterator >\nvoid BSPLib::SendIterator( uint32_t pid, tIterator begin,\n                           tIterator end )                              // (8) Begin-End  Send a buffered message to the processor with ID pid using a tag to identify the message.   Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that may either be a primitive or a contiguous container.  Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that starts at  tagPtr .  Has the same behaviour as (1), using that  count = end - begin .  Has the same behaviour as (2), using that  count = end - begin .  Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that is an entire C-Array.  Has the same behaviour as (5), using that  count = end - begin .  Has the same behaviour as (2), using that  tagPtr = nullptr , no tag is sent.  Has the same behaviour as (4), using that  tagPtr = nullptr , no tag is sent.    Tip   There are also other specialisations available. See\n   Containers ,  Primitives ,  Iterators ,\n   Pointes with Primitive Tags  and  Pointers with Container Tags .  You can safely pass both primitives and contiguous containers, like  std::vector \n  or  std:array  using the  tag  parameter. They will be specialised by \n   BSPLib::SendPtrs()  that is called internally.  If you want to use a reference to a primitive as a tag, have a look at\n   Send Memory - Pointers - Primitives .  If you want to use a reference to a container as a tag, have a look at\n   Send Memory - Pointers - Containers .     Warnings  Make sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See  BSPLib::SetTagSize() .",
            "title": "Interfaces"
        },
        {
            "location": "/messaging/sendIterator/#parameters",
            "text": "pid  The ID of the processor to send to.  tag  The tag by which the other processor can identify the message. This may be either a primitive or a contiguous container.  begin  Iterator describing the begin of the payload.  end  Iterator describing the end of the payload.  count  Number of primitives in the payload.  tagPtr  Pointer to the beginning of the tag.  tagContainer  C-Array containing the tag.",
            "title": "Parameters"
        },
        {
            "location": "/messaging/sendIterator/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  Tagsize is equal on all threads.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messaging/sendIterator/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messaging/sendIterator/#1_begin-count-reference",
            "text": "",
            "title": "(1) Begin-Count-Reference"
        },
        {
            "location": "/messaging/sendIterator/#2_begin-count-pointer",
            "text": "",
            "title": "(2) Begin-Count-Pointer"
        },
        {
            "location": "/messaging/sendIterator/#3_begin-end-reference",
            "text": "",
            "title": "(3) Begin-End-Reference"
        },
        {
            "location": "/messaging/sendIterator/#4_begin-end-pointer",
            "text": "",
            "title": "(4) Begin-End-Pointer"
        },
        {
            "location": "/messaging/sendIterator/#5_begin-count-carray",
            "text": "",
            "title": "(5) Begin-Count-CArray"
        },
        {
            "location": "/messaging/sendIterator/#6_begin-end-carray",
            "text": "",
            "title": "(6) Begin-End-CArray"
        },
        {
            "location": "/messaging/sendIterator/#7_begin-count",
            "text": "",
            "title": "(7) Begin-Count"
        },
        {
            "location": "/messaging/sendIterator/#8_begin-end",
            "text": "",
            "title": "(8) Begin-End"
        },
        {
            "location": "/messaging/sendContainer/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tTag, typename tContainer >\nvoid BSPLib::SendContainer( uint32_t pid, tTag *tag,\n                            tContainer &container )                     // (1) Container-Pointer\n\ntemplate< typename tTag, typename tContainer >\nvoid BSPLib::SendContainer( uint32_t pid, tTag &tag,\n                            tContainer &container )                     // (2) Container-Reference\n\ntemplate< typename tTagPrimitive, typename tContainer, size_t tTagSize >\nvoid BSPLib::SendContainerWithCArray( uint32_t pid, tTagPrimitive( &tag )[tTagSize],\n                                      tContainer &container )           // (3) Container-CArray\n\ntemplate< typename tContainer >\nvoid BSPLib::SendContainer( uint32_t pid, tContainer &container )       // (4) Container\n\ntemplate< typename tPrimitive, typename tTag, size_t tSize >\nvoid BSPLib::SendCArray( uint32_t pid, tTag *tag,\n                         tPrimitive( &payload )[tSize] )                // (5) CArray-Pointer\n\ntemplate< typename tPrimitive, typename tTag, size_t tSize >\nvoid BSPLib::SendCArray( uint32_t pid, tTag &tag,\n                         tPrimitive( &payload )[tSize] )                // (6) CArray-Reference\n\ntemplate< typename tPrimitive, typename tTagPrimitive, size_t tSize, size_t tTagSize >\nvoid BSPLib::SendCArrayWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize],\n                                   tPrimitive( &payload )[tSize] )      // (7) CArray-CArray\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::SendCArray( uint32_t pid, tPrimitive( &payload )[tSize] )  // (8) CArray\n\n\n\n\nSend a buffered message to the processor with ID pid using a tag to identify the message.\n\n\n\n\nSends an entire container as message, accompanied by a tag that may either be a primitive or a contiguous container.\n\n\nSends an entire container as message, accompanied by a tag that starts at \ntagPtr\n.\n\n\nSends an entire container as message, accompanied by a tag that is an entire C-Array.\n\n\nHas the same behaviour as (2), using that \ntagPtr = nullptr\n.\n\n\nSends an entire C-Array as message, accompanied by a tag that may either be a primitive or a contiguous container.\n\n\nSends an entire C-Array as message, accompanied by a tag that starts at \ntagPtr\n.\n\n\nSends an entire C-Array as message, accompanied by a tag that is an entire C-Array.\n\n\nHas the same behaviour as (6), using that \ntagPtr = nullptr\n.\n\n\n\n\n\n\nTip\n\n\n\n\nThere are also other specialisations available. See\n  \nContainers\n, \nPrimitives\n, \nIterators\n,\n  \nPointes with Primitive Tags\n and \nPointers with Container Tags\n.\n\n\nYou can safely pass both primitives and contiguous containers, like \nstd::vector\n\n  or \nstd:array\n using the \ntag\n parameter. They will be specialised by \n  \nBSPLib::SendPtrs()\n that is called internally.\n\n\nIf you want to use a reference to a primitive as a tag, have a look at\n  \nSend Memory - Pointers - Primitives\n.\n\n\nIf you want to use a reference to a container as a tag, have a look at\n  \nSend Memory - Pointers - Containers\n.\n\n\n\n\n\n\n\n\nWarnings\n\n\nMake sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See \nBSPLib::SetTagSize()\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to send to.\n\n\ntag\n The tag by which the other processor can identify the message. This may be either a primitive or a contiguous container.\n\n\nbegin\n Iterator describing the begin of the payload.\n\n\nend\n Iterator describing the end of the payload.\n\n\ncount\n Number of primitives in the payload.\n\n\ntagPtr\n Pointer to the beginning of the tag.\n\n\ntagContainer\n C-Array containing the tag.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nTagsize is equal on all threads.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Container-Pointer\n\u00b6\n\n\n(2) Container-Reference\n\u00b6\n\n\n(3) Container-CArray\n\u00b6\n\n\n(4) Container\n\u00b6\n\n\n(5) CArray-Pointer\n\u00b6\n\n\n(6) CArray-Reference\n\u00b6\n\n\n(7) CArray-CArray\n\u00b6\n\n\n(8) CArray\n\u00b6",
            "title": "Containers"
        },
        {
            "location": "/messaging/sendContainer/#interfaces",
            "text": "template< typename tTag, typename tContainer >\nvoid BSPLib::SendContainer( uint32_t pid, tTag *tag,\n                            tContainer &container )                     // (1) Container-Pointer\n\ntemplate< typename tTag, typename tContainer >\nvoid BSPLib::SendContainer( uint32_t pid, tTag &tag,\n                            tContainer &container )                     // (2) Container-Reference\n\ntemplate< typename tTagPrimitive, typename tContainer, size_t tTagSize >\nvoid BSPLib::SendContainerWithCArray( uint32_t pid, tTagPrimitive( &tag )[tTagSize],\n                                      tContainer &container )           // (3) Container-CArray\n\ntemplate< typename tContainer >\nvoid BSPLib::SendContainer( uint32_t pid, tContainer &container )       // (4) Container\n\ntemplate< typename tPrimitive, typename tTag, size_t tSize >\nvoid BSPLib::SendCArray( uint32_t pid, tTag *tag,\n                         tPrimitive( &payload )[tSize] )                // (5) CArray-Pointer\n\ntemplate< typename tPrimitive, typename tTag, size_t tSize >\nvoid BSPLib::SendCArray( uint32_t pid, tTag &tag,\n                         tPrimitive( &payload )[tSize] )                // (6) CArray-Reference\n\ntemplate< typename tPrimitive, typename tTagPrimitive, size_t tSize, size_t tTagSize >\nvoid BSPLib::SendCArrayWithCArray( uint32_t pid, tTagPrimitive( &tagContainer )[tTagSize],\n                                   tPrimitive( &payload )[tSize] )      // (7) CArray-CArray\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::SendCArray( uint32_t pid, tPrimitive( &payload )[tSize] )  // (8) CArray  Send a buffered message to the processor with ID pid using a tag to identify the message.   Sends an entire container as message, accompanied by a tag that may either be a primitive or a contiguous container.  Sends an entire container as message, accompanied by a tag that starts at  tagPtr .  Sends an entire container as message, accompanied by a tag that is an entire C-Array.  Has the same behaviour as (2), using that  tagPtr = nullptr .  Sends an entire C-Array as message, accompanied by a tag that may either be a primitive or a contiguous container.  Sends an entire C-Array as message, accompanied by a tag that starts at  tagPtr .  Sends an entire C-Array as message, accompanied by a tag that is an entire C-Array.  Has the same behaviour as (6), using that  tagPtr = nullptr .    Tip   There are also other specialisations available. See\n   Containers ,  Primitives ,  Iterators ,\n   Pointes with Primitive Tags  and  Pointers with Container Tags .  You can safely pass both primitives and contiguous containers, like  std::vector \n  or  std:array  using the  tag  parameter. They will be specialised by \n   BSPLib::SendPtrs()  that is called internally.  If you want to use a reference to a primitive as a tag, have a look at\n   Send Memory - Pointers - Primitives .  If you want to use a reference to a container as a tag, have a look at\n   Send Memory - Pointers - Containers .     Warnings  Make sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See  BSPLib::SetTagSize() .",
            "title": "Interfaces"
        },
        {
            "location": "/messaging/sendContainer/#parameters",
            "text": "pid  The ID of the processor to send to.  tag  The tag by which the other processor can identify the message. This may be either a primitive or a contiguous container.  begin  Iterator describing the begin of the payload.  end  Iterator describing the end of the payload.  count  Number of primitives in the payload.  tagPtr  Pointer to the beginning of the tag.  tagContainer  C-Array containing the tag.",
            "title": "Parameters"
        },
        {
            "location": "/messaging/sendContainer/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  Tagsize is equal on all threads.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messaging/sendContainer/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messaging/sendContainer/#1_container-pointer",
            "text": "",
            "title": "(1) Container-Pointer"
        },
        {
            "location": "/messaging/sendContainer/#2_container-reference",
            "text": "",
            "title": "(2) Container-Reference"
        },
        {
            "location": "/messaging/sendContainer/#3_container-carray",
            "text": "",
            "title": "(3) Container-CArray"
        },
        {
            "location": "/messaging/sendContainer/#4_container",
            "text": "",
            "title": "(4) Container"
        },
        {
            "location": "/messaging/sendContainer/#5_carray-pointer",
            "text": "",
            "title": "(5) CArray-Pointer"
        },
        {
            "location": "/messaging/sendContainer/#6_carray-reference",
            "text": "",
            "title": "(6) CArray-Reference"
        },
        {
            "location": "/messaging/sendContainer/#7_carray-carray",
            "text": "",
            "title": "(7) CArray-CArray"
        },
        {
            "location": "/messaging/sendContainer/#8_carray",
            "text": "",
            "title": "(8) CArray"
        },
        {
            "location": "/messaging/sendPtrs/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tPrimitive, typename tTagPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, tTagPrimitive *tag, tPrimitive *begin,\n                       size_t count )                               // (1) Begin-Count-Pointer\n\ntemplate< typename tPrimitive, typename tTagPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, tTagPrimitive *tag, tPrimitive *begin,\n                       tPrimitive *end )                            // (2) Begin-End-Pointer\n\ntemplate< typename tPrimitive, typename tTag >\nvoid BSPLib::SendPtrs( uint32_t pid, const tTag &tag, tPrimitive *begin,\n                       size_t count )                               // (3) Begin-Count-Reference\n\ntemplate< typename tPrimitive, typename tTag >\nvoid BSPLib::SendPtrs( uint32_t pid, const tTag &tag, tPrimitive *begin,\n                       tPrimitive *end )                            // (4) Begin-End-Reference\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, const std::string &tag, tPrimitive *begin,\n                       tPrimitive *end )                            // (5) Begin-End-std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, const std::string &tag, tPrimitive *begin,\n                       size_t count )                               // (6) Begin-Count-std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, tPrimitive *begin, \n                       size_t count )                               // (7) Begin-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, tPrimitive *begin,\n                       tPrimitive *end )                            // (8) Begin-End\n\n\n\n\nSend a buffered message to the processor with ID pid using a tag to identify the message.\n\n\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that may either be a primitive or a contiguous container.\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that starts at \ntagPtr\n.\n\n\nHas the same behaviour as (1), using that \ncount = end - begin\n.\n\n\nHas the same behaviour as (2), using that \ncount = end - begin\n.\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that is an entire C-Array.\n\n\nHas the same behaviour as (5), using that \ncount = end - begin\n.\n\n\nHas the same behaviour as (2), using that \ntagPtr = nullptr\n, no tag is sent.\n\n\nHas the same behaviour as (4), using that \ntagPtr = nullptr\n, no tag is sent.\n\n\n\n\n\n\nTip\n\n\n\n\nThere are also other specialisations available. See\n  \nContainers\n, \nPrimitives\n, \nIterators\n,\n  \nPointes with Primitive Tags\n and \nPointers with Container Tags\n.\n\n\nYou can safely pass both primitives and contiguous containers, like \nstd::vector\n\n  or \nstd:array\n using the \ntag\n parameter. They will be specialised by \n  \nBSPLib::SendPtrs()\n that is called internally.\n\n\nIf you want to use a reference to a primitive as a tag, have a look at\n  \nSend Memory - Pointers - Primitives\n.\n\n\nIf you want to use a reference to a container as a tag, have a look at\n  \nSend Memory - Pointers - Containers\n.\n\n\n\n\n\n\n\n\nWarnings\n\n\nMake sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See \nBSPLib::SetTagSize()\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to send to.\n\n\ntag\n The tag by which the other processor can identify the message. This may be either a primitive or a contiguous container.\n\n\nbegin\n Pointer to the begin of the payload.\n\n\nend\n Pointer to the end of the payload.\n\n\ncount\n Number of primitives in the payload.\n\n\ntagPtr\n Pointer to the beginning of the tag.\n\n\ntagCArray\n C-Array containing the tag.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nTagsize is equal on all threads.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Begin-Count-Reference\n\u00b6\n\n\n(2) Begin-End-Pointer\n\u00b6\n\n\n(3) Begin-Count-Pointer\n\u00b6\n\n\n(4) Begin-End-Reference\n\u00b6\n\n\n(5) Begin-Count-std::string\n\u00b6\n\n\n(6) Begin-End-std::string\n\u00b6\n\n\n(7) Begin-Count\n\u00b6\n\n\n(8) Begin-End\n\u00b6",
            "title": "Pointers - Primitives"
        },
        {
            "location": "/messaging/sendPtrs/#interfaces",
            "text": "template< typename tPrimitive, typename tTagPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, tTagPrimitive *tag, tPrimitive *begin,\n                       size_t count )                               // (1) Begin-Count-Pointer\n\ntemplate< typename tPrimitive, typename tTagPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, tTagPrimitive *tag, tPrimitive *begin,\n                       tPrimitive *end )                            // (2) Begin-End-Pointer\n\ntemplate< typename tPrimitive, typename tTag >\nvoid BSPLib::SendPtrs( uint32_t pid, const tTag &tag, tPrimitive *begin,\n                       size_t count )                               // (3) Begin-Count-Reference\n\ntemplate< typename tPrimitive, typename tTag >\nvoid BSPLib::SendPtrs( uint32_t pid, const tTag &tag, tPrimitive *begin,\n                       tPrimitive *end )                            // (4) Begin-End-Reference\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, const std::string &tag, tPrimitive *begin,\n                       tPrimitive *end )                            // (5) Begin-End-std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, const std::string &tag, tPrimitive *begin,\n                       size_t count )                               // (6) Begin-Count-std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, tPrimitive *begin, \n                       size_t count )                               // (7) Begin-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, tPrimitive *begin,\n                       tPrimitive *end )                            // (8) Begin-End  Send a buffered message to the processor with ID pid using a tag to identify the message.   Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that may either be a primitive or a contiguous container.  Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that starts at  tagPtr .  Has the same behaviour as (1), using that  count = end - begin .  Has the same behaviour as (2), using that  count = end - begin .  Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that is an entire C-Array.  Has the same behaviour as (5), using that  count = end - begin .  Has the same behaviour as (2), using that  tagPtr = nullptr , no tag is sent.  Has the same behaviour as (4), using that  tagPtr = nullptr , no tag is sent.    Tip   There are also other specialisations available. See\n   Containers ,  Primitives ,  Iterators ,\n   Pointes with Primitive Tags  and  Pointers with Container Tags .  You can safely pass both primitives and contiguous containers, like  std::vector \n  or  std:array  using the  tag  parameter. They will be specialised by \n   BSPLib::SendPtrs()  that is called internally.  If you want to use a reference to a primitive as a tag, have a look at\n   Send Memory - Pointers - Primitives .  If you want to use a reference to a container as a tag, have a look at\n   Send Memory - Pointers - Containers .     Warnings  Make sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See  BSPLib::SetTagSize() .",
            "title": "Interfaces"
        },
        {
            "location": "/messaging/sendPtrs/#parameters",
            "text": "pid  The ID of the processor to send to.  tag  The tag by which the other processor can identify the message. This may be either a primitive or a contiguous container.  begin  Pointer to the begin of the payload.  end  Pointer to the end of the payload.  count  Number of primitives in the payload.  tagPtr  Pointer to the beginning of the tag.  tagCArray  C-Array containing the tag.",
            "title": "Parameters"
        },
        {
            "location": "/messaging/sendPtrs/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  Tagsize is equal on all threads.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messaging/sendPtrs/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messaging/sendPtrs/#1_begin-count-reference",
            "text": "",
            "title": "(1) Begin-Count-Reference"
        },
        {
            "location": "/messaging/sendPtrs/#2_begin-end-pointer",
            "text": "",
            "title": "(2) Begin-End-Pointer"
        },
        {
            "location": "/messaging/sendPtrs/#3_begin-count-pointer",
            "text": "",
            "title": "(3) Begin-Count-Pointer"
        },
        {
            "location": "/messaging/sendPtrs/#4_begin-end-reference",
            "text": "",
            "title": "(4) Begin-End-Reference"
        },
        {
            "location": "/messaging/sendPtrs/#5_begin-count-stdstring",
            "text": "",
            "title": "(5) Begin-Count-std::string"
        },
        {
            "location": "/messaging/sendPtrs/#6_begin-end-stdstring",
            "text": "",
            "title": "(6) Begin-End-std::string"
        },
        {
            "location": "/messaging/sendPtrs/#7_begin-count",
            "text": "",
            "title": "(7) Begin-Count"
        },
        {
            "location": "/messaging/sendPtrs/#8_begin-end",
            "text": "",
            "title": "(8) Begin-End"
        },
        {
            "location": "/messaging/sendTagContainer/",
            "text": "Interfaces\n\u00b6\n\n\ntemplate< typename tPrimitive, typename tTagPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, std::vector< tTagPrimitive > &tagVector, tPrimitive *begin, \n                       size_t count )                                           // (1) Begin-Count-Vector\n\ntemplate< typename tPrimitive, typename tTagPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, std::vector< tTagPrimitive > &tagVector, tPrimitive *begin,\n                       tPrimitive *end )                                        // (2) Begin-End-Vector\n\ntemplate< typename tPrimitive, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendPtrs( uint32_t pid, std::array< tTagPrimitive, tTagSize > &tagArray,\n                       tPrimitive *begin, size_t count )                        // (3) Begin-Count-StdArray\n\ntemplate< typename tPrimitive, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendPtrs( uint32_t pid, std::array< tTagPrimitive, tTagSize > &tagArray,\n                       tPrimitive *begin, tPrimitive *end )                     // (4) Begin-End-StdArray\n\ntemplate< typename tPrimitive, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendPtrsWithCArray( uint32_t pid, tTagPrimitive( &tagCArray )[tTagSize],\n                                 tPrimitive *begin, size_t count )              // (5) Begin-Count-CArray\n\ntemplate< typename tPrimitive, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendPtrsWithCArray( uint32_t pid, tTagPrimitive( &tagCArray )[tTagSize],\n                                 tPrimitive *begin, tPrimitive *end )           // (6) Begin-End-CArray\n\n\n\n\nSend a buffered message to the processor with ID pid using a tag to identify the message.\n\n\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that consists of an entire \nstd::vector\n.\n\n\nHas the same behaviour as (1), using that \ncount = end - begin\n.\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that consists of an entire \nstd::array\n.\n\n\nHas the same behaviour as (3), using that \ncount = end - begin\n.\n\n\nSends a block of \ncount\n primitives starting at \nbegin\n as message, accompanied by a tag that consists of an entire C-Array.\n\n\nHas the same behaviour as (5), using that \ncount = end - begin\n.\n\n\n\n\n\n\nTip\n\n\n\n\nThere are also other specialisations available. See\n  \nContainers\n, \nPrimitives\n, \nIterators\n,\n  \nPointes with Primitive Tags\n and \nPointers with Container Tags\n.\n\n\nYou can safely pass both primitives and contiguous containers, like \nstd::vector\n\n  or \nstd:array\n using the \ntag\n parameter. They will be specialised by \n  \nBSPLib::SendPtrs()\n that is called internally.\n\n\nIf you want to use a reference to a primitive as a tag, have a look at\n  \nSend Memory - Pointers - Primitives\n.\n\n\nIf you want to use a reference to a container as a tag, have a look at\n  \nSend Memory - Pointers - Containers\n.\n\n\n\n\n\n\n\n\nWarnings\n\n\nMake sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See \nBSPLib::SetTagSize()\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npid\n The ID of the processor to send to.\n\n\nbegin\n Iterator describing the begin of the payload.\n\n\nend\n Iterator describing the end of the payload.\n\n\ncount\n Number of primitives in the payload.\n\n\ntagVector\n \nstd::vector\n containing the entire tag.\n\n\ntagArray\n \nstd::array\n containing the entire tag.\n\n\ntagCArray\n C-Array containing the entire tag.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nTagsize is equal on all threads.\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Begin-Count-Vector\n\u00b6\n\n\n(2) Begin-End-Vector\n\u00b6\n\n\n(3) Begin-Count-StdArray\n\u00b6\n\n\n(4) Begin-End-StdArray\n\u00b6\n\n\n(5) Begin-Count-CArray\n\u00b6\n\n\n(6) Begin-End-CArray\n\u00b6",
            "title": "Pointers - Containers"
        },
        {
            "location": "/messaging/sendTagContainer/#interfaces",
            "text": "template< typename tPrimitive, typename tTagPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, std::vector< tTagPrimitive > &tagVector, tPrimitive *begin, \n                       size_t count )                                           // (1) Begin-Count-Vector\n\ntemplate< typename tPrimitive, typename tTagPrimitive >\nvoid BSPLib::SendPtrs( uint32_t pid, std::vector< tTagPrimitive > &tagVector, tPrimitive *begin,\n                       tPrimitive *end )                                        // (2) Begin-End-Vector\n\ntemplate< typename tPrimitive, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendPtrs( uint32_t pid, std::array< tTagPrimitive, tTagSize > &tagArray,\n                       tPrimitive *begin, size_t count )                        // (3) Begin-Count-StdArray\n\ntemplate< typename tPrimitive, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendPtrs( uint32_t pid, std::array< tTagPrimitive, tTagSize > &tagArray,\n                       tPrimitive *begin, tPrimitive *end )                     // (4) Begin-End-StdArray\n\ntemplate< typename tPrimitive, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendPtrsWithCArray( uint32_t pid, tTagPrimitive( &tagCArray )[tTagSize],\n                                 tPrimitive *begin, size_t count )              // (5) Begin-Count-CArray\n\ntemplate< typename tPrimitive, typename tTagPrimitive, uint32_t tTagSize >\nvoid BSPLib::SendPtrsWithCArray( uint32_t pid, tTagPrimitive( &tagCArray )[tTagSize],\n                                 tPrimitive *begin, tPrimitive *end )           // (6) Begin-End-CArray  Send a buffered message to the processor with ID pid using a tag to identify the message.   Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that consists of an entire  std::vector .  Has the same behaviour as (1), using that  count = end - begin .  Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that consists of an entire  std::array .  Has the same behaviour as (3), using that  count = end - begin .  Sends a block of  count  primitives starting at  begin  as message, accompanied by a tag that consists of an entire C-Array.  Has the same behaviour as (5), using that  count = end - begin .    Tip   There are also other specialisations available. See\n   Containers ,  Primitives ,  Iterators ,\n   Pointes with Primitive Tags  and  Pointers with Container Tags .  You can safely pass both primitives and contiguous containers, like  std::vector \n  or  std:array  using the  tag  parameter. They will be specialised by \n   BSPLib::SendPtrs()  that is called internally.  If you want to use a reference to a primitive as a tag, have a look at\n   Send Memory - Pointers - Primitives .  If you want to use a reference to a container as a tag, have a look at\n   Send Memory - Pointers - Containers .     Warnings  Make sure that in all cases, the tagsize is appropriately set. Using these functions does not guarantee that the tagsize\nis always correct. See  BSPLib::SetTagSize() .",
            "title": "Interfaces"
        },
        {
            "location": "/messaging/sendTagContainer/#parameters",
            "text": "pid  The ID of the processor to send to.  begin  Iterator describing the begin of the payload.  end  Iterator describing the end of the payload.  count  Number of primitives in the payload.  tagVector   std::vector  containing the entire tag.  tagArray   std::array  containing the entire tag.  tagCArray  C-Array containing the entire tag.",
            "title": "Parameters"
        },
        {
            "location": "/messaging/sendTagContainer/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  Tagsize is equal on all threads.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messaging/sendTagContainer/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messaging/sendTagContainer/#1_begin-count-vector",
            "text": "",
            "title": "(1) Begin-Count-Vector"
        },
        {
            "location": "/messaging/sendTagContainer/#2_begin-end-vector",
            "text": "",
            "title": "(2) Begin-End-Vector"
        },
        {
            "location": "/messaging/sendTagContainer/#3_begin-count-stdarray",
            "text": "",
            "title": "(3) Begin-Count-StdArray"
        },
        {
            "location": "/messaging/sendTagContainer/#4_begin-end-stdarray",
            "text": "",
            "title": "(4) Begin-End-StdArray"
        },
        {
            "location": "/messaging/sendTagContainer/#5_begin-count-carray",
            "text": "",
            "title": "(5) Begin-Count-CArray"
        },
        {
            "location": "/messaging/sendTagContainer/#6_begin-end-carray",
            "text": "",
            "title": "(6) Begin-End-CArray"
        },
        {
            "location": "/messaging/move/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::Move( void *payload, size_t max_copy_size_in )    // (1) Classic\nvoid bsp_move( void *payload, size_t max_copy_size_in )                 // (2) Legacy\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Move( tPrimitive &payloadRef )                             // (3) Reference\n\ntemplate<>\nvoid BSPLib::Move( std::string &payloadRef )                            // (4) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::MovePtrs( tPrimitive *begin, uint32_t maxCopySize )        // (5) Pointers: Begin-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::MovePtrs( tPrimitive *begin, tPrimitive *end )             // (6) Pointers: Begin-End\n\ntemplate< typename tIterator >\nvoid BSPLib::MoveIterator( tIterator beginIt, uint32_t maxCopySize )    // (7) Iterators: Begin-Count\n\ntemplate< typename tIterator >\nvoid BSPLib::MoveIterator( tIterator beginIt, tIterator endIt )         // (8) Iterators: Begin-End\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::MoveCArray( tPrimitive( &payloadCArray )[tSize] )          // (9) C-Array\n\ntemplate< typename tContainer >\nvoid BSPLib::MoveContainer( tContainer &payloadContainer )              // (10) Container\n\n\n\n\nMoves the first message in the queue to the given payload destination.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\nMoves the first message in the queue to the given primitive.\n\n\nOverload of (3) for \nstd::string\n.\n\n\nMoves the first message in the queue to \nbegin\n, with up to \nmaxCopySize\n primitives.\n\n\nHas the same behaviour as (5), using that \nmaxCopySize = begin - end\n.\n\n\nMoves the first message in the queue to \nbeginIt\n, with up to \nmaxCopySize\n primitives.\n\n\nHas the same behaviour as (5), using that \nmaxCopySize = beginIt - endIt\n.\n\n\nMoves the first message in the queue to the C-Array.\n\n\nMoves the first message in the queue to the container.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npayload\n Void pointer to the begin of the payload destination.\n\n\nmax_copy_size_in\n Maximum size in bytes for the payload destination. No more than this will be copied (may copy less).\n\n\npayloadRef\n Reference to store the payload to.\n\n\nbegin\n Typesafe pointer to the begin of the payload destination.\n\n\nmaxCopySize\n Maximum number of primitives for the payload destination. Similar to \nmax_copy_size_in\n, but not in bytes.\n\n\nend\n Typesafe pointer to the end of the payload destination.\n\n\nbeginIt\n Iterator describing the begin of the payload destination.\n\n\nendIt\n Iterator describing the end of the payload destination.\n\n\npayloadCArray\n C-Array that is the destination for the payload.\n\n\npayloadContainer\n Container that is the destination for the payload.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBegin has been called.\n\n\n\n\nIf the send queue is empty or the cursor is at/behind the end:\n\n\n\n\nDoes nothing.\n\n\n\n\nElse:\n\n\n\n\nMoves the first message in the queue o the given payload destination.\n\n\npayload != nullptr.\n\n\n\n\n\n\n\n\nPost-Conditions\n\u00b6\n\n\nThe queue cursor for the send queue is moved to the next message.\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\n(2) Legacy\n\u00b6\n\n\n(3) Reference\n\u00b6\n\n\n(4) std::string\n\u00b6\n\n\n(5) Pointers: Begin-Count\n\u00b6\n\n\n(6) Pointers: Begin-End\n\u00b6\n\n\n(7) Iterators: Begin-Count\n\u00b6\n\n\n(8) Iterators: Begin-End\n\u00b6\n\n\n(9) C-Array\n\u00b6\n\n\n(10) Container\n\u00b6",
            "title": "Move Memory"
        },
        {
            "location": "/messaging/move/#interfaces",
            "text": "void BSPLib::Classic::Move( void *payload, size_t max_copy_size_in )    // (1) Classic\nvoid bsp_move( void *payload, size_t max_copy_size_in )                 // (2) Legacy\n\ntemplate< typename tPrimitive >\nvoid BSPLib::Move( tPrimitive &payloadRef )                             // (3) Reference\n\ntemplate<>\nvoid BSPLib::Move( std::string &payloadRef )                            // (4) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::MovePtrs( tPrimitive *begin, uint32_t maxCopySize )        // (5) Pointers: Begin-Count\n\ntemplate< typename tPrimitive >\nvoid BSPLib::MovePtrs( tPrimitive *begin, tPrimitive *end )             // (6) Pointers: Begin-End\n\ntemplate< typename tIterator >\nvoid BSPLib::MoveIterator( tIterator beginIt, uint32_t maxCopySize )    // (7) Iterators: Begin-Count\n\ntemplate< typename tIterator >\nvoid BSPLib::MoveIterator( tIterator beginIt, tIterator endIt )         // (8) Iterators: Begin-End\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::MoveCArray( tPrimitive( &payloadCArray )[tSize] )          // (9) C-Array\n\ntemplate< typename tContainer >\nvoid BSPLib::MoveContainer( tContainer &payloadContainer )              // (10) Container  Moves the first message in the queue to the given payload destination.   Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.  Moves the first message in the queue to the given primitive.  Overload of (3) for  std::string .  Moves the first message in the queue to  begin , with up to  maxCopySize  primitives.  Has the same behaviour as (5), using that  maxCopySize = begin - end .  Moves the first message in the queue to  beginIt , with up to  maxCopySize  primitives.  Has the same behaviour as (5), using that  maxCopySize = beginIt - endIt .  Moves the first message in the queue to the C-Array.  Moves the first message in the queue to the container.",
            "title": "Interfaces"
        },
        {
            "location": "/messaging/move/#parameters",
            "text": "payload  Void pointer to the begin of the payload destination.  max_copy_size_in  Maximum size in bytes for the payload destination. No more than this will be copied (may copy less).  payloadRef  Reference to store the payload to.  begin  Typesafe pointer to the begin of the payload destination.  maxCopySize  Maximum number of primitives for the payload destination. Similar to  max_copy_size_in , but not in bytes.  end  Typesafe pointer to the end of the payload destination.  beginIt  Iterator describing the begin of the payload destination.  endIt  Iterator describing the end of the payload destination.  payloadCArray  C-Array that is the destination for the payload.  payloadContainer  Container that is the destination for the payload.",
            "title": "Parameters"
        },
        {
            "location": "/messaging/move/#pre-conditions",
            "text": "Begin has been called.   If the send queue is empty or the cursor is at/behind the end:   Does nothing.   Else:   Moves the first message in the queue o the given payload destination.  payload != nullptr.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messaging/move/#post-conditions",
            "text": "The queue cursor for the send queue is moved to the next message.",
            "title": "Post-Conditions"
        },
        {
            "location": "/messaging/move/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messaging/move/#1_classic",
            "text": "",
            "title": "(1) Classic"
        },
        {
            "location": "/messaging/move/#2_legacy",
            "text": "",
            "title": "(2) Legacy"
        },
        {
            "location": "/messaging/move/#3_reference",
            "text": "",
            "title": "(3) Reference"
        },
        {
            "location": "/messaging/move/#4_stdstring",
            "text": "",
            "title": "(4) std::string"
        },
        {
            "location": "/messaging/move/#5_pointers_begin-count",
            "text": "",
            "title": "(5) Pointers: Begin-Count"
        },
        {
            "location": "/messaging/move/#6_pointers_begin-end",
            "text": "",
            "title": "(6) Pointers: Begin-End"
        },
        {
            "location": "/messaging/move/#7_iterators_begin-count",
            "text": "",
            "title": "(7) Iterators: Begin-Count"
        },
        {
            "location": "/messaging/move/#8_iterators_begin-end",
            "text": "",
            "title": "(8) Iterators: Begin-End"
        },
        {
            "location": "/messaging/move/#9_c-array",
            "text": "",
            "title": "(9) C-Array"
        },
        {
            "location": "/messaging/move/#10_container",
            "text": "",
            "title": "(10) Container"
        },
        {
            "location": "/messaging/qsize/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::QSize( size_t *packets, size_t *accumulatedSize ) // (1) Classic\nvoid bsp_qsize( size_t *packets, size_t *accumulatedSize )              // (2) Legacy\n\nvoid BSPLib::QSize( size_t &packetsRef )                                // (3) Reference\nvoid BSPLib::QSize( size_t &packetsRef, size_t &accumulatedSizeRef )    // (4) References\n\n\n\n\nGet both the amount of messages, and the total size of the messages in bytes.\n\n\n\n\nClassic BSP function, this is the interface one should prefer to use over the old BSP interface.\n\n\nLegacy BSP function, this interface is included for backwards compatibility with other BSP libraries.\n\n\nGets the amount of messages in the queue using a reference, as we do not allow \npackets\n to be \nnullptr\n.\n\n\nGets both the amount of messages in the queue and the total size of the messages in bytes, using references.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\npackets\n Pointer to the location where the total number of packets is to be written.\n\n\naccumulatedSize\n Pointer to the location where the total size of the messages is to be written.\n\n\npacketsRef\n Reference to write the number of packets to.\n\n\naccumulatedSizeRef\n Reference to write the total size of the messages to.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\npackets != nullptr.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\n\n\n\n\nIf \naccumulatedSize != nullptr\n:\n\n\n\n\naccumulatedSize will be the accumulated size of the packets in bytes.\n\n\n\n\nElse:\n\n\n\n\nThe calculation of the accumulated size will be skipped.\n\n\n\n\n\n\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\n(2) Legacy\n\u00b6\n\n\n(3) Reference\n\u00b6\n\n\n(4) References\n\u00b6",
            "title": "Get Queue Size"
        },
        {
            "location": "/messaging/qsize/#interfaces",
            "text": "void BSPLib::Classic::QSize( size_t *packets, size_t *accumulatedSize ) // (1) Classic\nvoid bsp_qsize( size_t *packets, size_t *accumulatedSize )              // (2) Legacy\n\nvoid BSPLib::QSize( size_t &packetsRef )                                // (3) Reference\nvoid BSPLib::QSize( size_t &packetsRef, size_t &accumulatedSizeRef )    // (4) References  Get both the amount of messages, and the total size of the messages in bytes.   Classic BSP function, this is the interface one should prefer to use over the old BSP interface.  Legacy BSP function, this interface is included for backwards compatibility with other BSP libraries.  Gets the amount of messages in the queue using a reference, as we do not allow  packets  to be  nullptr .  Gets both the amount of messages in the queue and the total size of the messages in bytes, using references.",
            "title": "Interfaces"
        },
        {
            "location": "/messaging/qsize/#parameters",
            "text": "packets  Pointer to the location where the total number of packets is to be written.  accumulatedSize  Pointer to the location where the total size of the messages is to be written.  packetsRef  Reference to write the number of packets to.  accumulatedSizeRef  Reference to write the total size of the messages to.",
            "title": "Parameters"
        },
        {
            "location": "/messaging/qsize/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  packets != nullptr.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messaging/qsize/#post-conditions",
            "text": "If  accumulatedSize != nullptr :   accumulatedSize will be the accumulated size of the packets in bytes.   Else:   The calculation of the accumulated size will be skipped.",
            "title": "Post-Conditions"
        },
        {
            "location": "/messaging/qsize/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messaging/qsize/#1_classic",
            "text": "",
            "title": "(1) Classic"
        },
        {
            "location": "/messaging/qsize/#2_legacy",
            "text": "",
            "title": "(2) Legacy"
        },
        {
            "location": "/messaging/qsize/#3_reference",
            "text": "",
            "title": "(3) Reference"
        },
        {
            "location": "/messaging/qsize/#4_references",
            "text": "",
            "title": "(4) References"
        },
        {
            "location": "/messagingutil/gettag/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::GetTag( size_t *status, void *tag )               // (1) Classic\nvoid bsp_get_tag( size_t *status, void *tag )                           // (2) Legacy\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetTag( size_t &statusRef, tPrimitive &tagRef )            // (3) Reference\n\ntemplate<>\nvoid BSPLib::GetTag( size_t &statusRef, std::string &tagRef )           // (4) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetTagPtr( size_t &statusRef, tPrimitive *tagPtr )              // (5) Pointer\n\ntemplate< typename tIterator >\nvoid BSPLib::GetTagIterator( size_t &statusRef, tIterator tagBegin )         // (6) Iterator\n\ntemplate< typename tContainer >\nvoid BSPLib::GetTagContainer( size_t &statusRef, tContainer &tagContainer )  // (7) Container\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::GetTagCArray( size_t &statusRef, tPrimitive( &tagCArray )[tSize] ) // (8) C-Array\n\n\n\n\nGets the tag for the next message in the send queue.\n\n\n\n\nClassic BSP function.\n\n\nLegacy BSP function\n\n\nUses a reference for \nstatus\n, as it is not allowed to be \nnullptr\n. \n   Uses a reference to store the tag.\n\n\nSpecialisation of (3) for \nstd::string\n.\n\n\nUses a reference for \nstatus\n. More typesafe version for the tag pointer.\n\n\nUses a reference for \nstatus\n. Uses an iterator to describe te beginning of the tag.\n\n\nUses a reference for \nstatus\n. Uses a container to store the tag.\n\n\nUses a reference for \nstatus\n. Uses a C-Array to store the tag. \n\n\n\n\nParameters\n\u00b6\n\n\n\n\nstatus\n Void pointer to store the status to.\n\n\ntag\n Void pointer to store the tag to.\n\n\nstatusRef\n Reference to store the status to.\n\n\ntagRef\n Reference to store the tag to.\n\n\ntagPtr\n Typesafe pointer to store the tag to.\n\n\ntagBegin\n Iterator describing the begin of the tag.\n\n\ntagContainer\n Container to store the tag to.\n\n\ntagCArray\n C-Array to store the tag to.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\n\n\nIf the send queue is empty or the cursor is at/behind the end of the queue:\n\n\n\n\nReturns a status equal to \n-1\n.\n\n\n\n\nElse:\n\n\n\n\nReturns the size of the buffer of the request as status.\n\n\nWrites the tag to the desired destination.\n\n\n\n\n\n\n\n\nPost-Conditions\n\u00b6\n\n\nThe queue is in the same state as before.\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\n(2) Legacy\n\u00b6\n\n\n(3) Reference\n\u00b6\n\n\n(4) std::string\n\u00b6\n\n\n(5) Pointer\n\u00b6\n\n\n(6) Iterator\n\u00b6\n\n\n(7) Container\n\u00b6\n\n\n(8) C-Array\n\u00b6",
            "title": "Get Tag"
        },
        {
            "location": "/messagingutil/gettag/#interfaces",
            "text": "void BSPLib::Classic::GetTag( size_t *status, void *tag )               // (1) Classic\nvoid bsp_get_tag( size_t *status, void *tag )                           // (2) Legacy\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetTag( size_t &statusRef, tPrimitive &tagRef )            // (3) Reference\n\ntemplate<>\nvoid BSPLib::GetTag( size_t &statusRef, std::string &tagRef )           // (4) std::string\n\ntemplate< typename tPrimitive >\nvoid BSPLib::GetTagPtr( size_t &statusRef, tPrimitive *tagPtr )              // (5) Pointer\n\ntemplate< typename tIterator >\nvoid BSPLib::GetTagIterator( size_t &statusRef, tIterator tagBegin )         // (6) Iterator\n\ntemplate< typename tContainer >\nvoid BSPLib::GetTagContainer( size_t &statusRef, tContainer &tagContainer )  // (7) Container\n\ntemplate< typename tPrimitive, size_t tSize >\nvoid BSPLib::GetTagCArray( size_t &statusRef, tPrimitive( &tagCArray )[tSize] ) // (8) C-Array  Gets the tag for the next message in the send queue.   Classic BSP function.  Legacy BSP function  Uses a reference for  status , as it is not allowed to be  nullptr . \n   Uses a reference to store the tag.  Specialisation of (3) for  std::string .  Uses a reference for  status . More typesafe version for the tag pointer.  Uses a reference for  status . Uses an iterator to describe te beginning of the tag.  Uses a reference for  status . Uses a container to store the tag.  Uses a reference for  status . Uses a C-Array to store the tag.",
            "title": "Interfaces"
        },
        {
            "location": "/messagingutil/gettag/#parameters",
            "text": "status  Void pointer to store the status to.  tag  Void pointer to store the tag to.  statusRef  Reference to store the status to.  tagRef  Reference to store the tag to.  tagPtr  Typesafe pointer to store the tag to.  tagBegin  Iterator describing the begin of the tag.  tagContainer  Container to store the tag to.  tagCArray  C-Array to store the tag to.",
            "title": "Parameters"
        },
        {
            "location": "/messagingutil/gettag/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.   If the send queue is empty or the cursor is at/behind the end of the queue:   Returns a status equal to  -1 .   Else:   Returns the size of the buffer of the request as status.  Writes the tag to the desired destination.",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messagingutil/gettag/#post-conditions",
            "text": "The queue is in the same state as before.",
            "title": "Post-Conditions"
        },
        {
            "location": "/messagingutil/gettag/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messagingutil/gettag/#1_classic",
            "text": "",
            "title": "(1) Classic"
        },
        {
            "location": "/messagingutil/gettag/#2_legacy",
            "text": "",
            "title": "(2) Legacy"
        },
        {
            "location": "/messagingutil/gettag/#3_reference",
            "text": "",
            "title": "(3) Reference"
        },
        {
            "location": "/messagingutil/gettag/#4_stdstring",
            "text": "",
            "title": "(4) std::string"
        },
        {
            "location": "/messagingutil/gettag/#5_pointer",
            "text": "",
            "title": "(5) Pointer"
        },
        {
            "location": "/messagingutil/gettag/#6_iterator",
            "text": "",
            "title": "(6) Iterator"
        },
        {
            "location": "/messagingutil/gettag/#7_container",
            "text": "",
            "title": "(7) Container"
        },
        {
            "location": "/messagingutil/gettag/#8_c-array",
            "text": "",
            "title": "(8) C-Array"
        },
        {
            "location": "/messagingutil/settagsize/",
            "text": "Interfaces\n\u00b6\n\n\nvoid BSPLib::Classic::SetTagSize( size_t *size )    // (1) Classic\nvoid bsp_set_tagsize( size_t *size )                // (2) Legacy\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SetTagsize()                           // (3) Primitive\n\ntemplate< typename tPrimitive >\nvoid SetTagsize( uint32_t count )                   // (4) Count\n\n\n\n\nSets a tagsize for the next superstep.\n\n\n\n\nClassic BSP function.\n\n\nLegacy BSP function\n\n\nSets the tagsize to the size of a primitive, \nsizeof(tPrimitive)\n \n   will be the new tagsize.\n\n\nSets the tagsize to the size of count primitives, \ncount * sizeof(tPrimitive)\n.\n\n\n\n\nParameters\n\u00b6\n\n\n\n\nsize\n Pointer to the desired size.\n\n\ncount\n Number of primitives to set the tagsize to.\n\n\n\n\nPre-Conditions\n\u00b6\n\n\n\n\nBSPLib::Begin()\n has been called.\n\n\nsize != nullptr\n.\n\n\n\n\nPost-Conditions\n\u00b6\n\n\nThe tagsize will be updated during the next \nsynchronization\n\n\nExamples\n\u00b6\n\n\n(1) Classic\n\u00b6\n\n\n(2) Legacy\n\u00b6\n\n\n(3) Primitive\n\u00b6\n\n\n(4) Count\n\u00b6",
            "title": "Set Tag Size"
        },
        {
            "location": "/messagingutil/settagsize/#interfaces",
            "text": "void BSPLib::Classic::SetTagSize( size_t *size )    // (1) Classic\nvoid bsp_set_tagsize( size_t *size )                // (2) Legacy\n\ntemplate< typename tPrimitive >\nvoid BSPLib::SetTagsize()                           // (3) Primitive\n\ntemplate< typename tPrimitive >\nvoid SetTagsize( uint32_t count )                   // (4) Count  Sets a tagsize for the next superstep.   Classic BSP function.  Legacy BSP function  Sets the tagsize to the size of a primitive,  sizeof(tPrimitive)  \n   will be the new tagsize.  Sets the tagsize to the size of count primitives,  count * sizeof(tPrimitive) .",
            "title": "Interfaces"
        },
        {
            "location": "/messagingutil/settagsize/#parameters",
            "text": "size  Pointer to the desired size.  count  Number of primitives to set the tagsize to.",
            "title": "Parameters"
        },
        {
            "location": "/messagingutil/settagsize/#pre-conditions",
            "text": "BSPLib::Begin()  has been called.  size != nullptr .",
            "title": "Pre-Conditions"
        },
        {
            "location": "/messagingutil/settagsize/#post-conditions",
            "text": "The tagsize will be updated during the next  synchronization",
            "title": "Post-Conditions"
        },
        {
            "location": "/messagingutil/settagsize/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/messagingutil/settagsize/#1_classic",
            "text": "",
            "title": "(1) Classic"
        },
        {
            "location": "/messagingutil/settagsize/#2_legacy",
            "text": "",
            "title": "(2) Legacy"
        },
        {
            "location": "/messagingutil/settagsize/#3_primitive",
            "text": "",
            "title": "(3) Primitive"
        },
        {
            "location": "/messagingutil/settagsize/#4_count",
            "text": "",
            "title": "(4) Count"
        }
    ]
}